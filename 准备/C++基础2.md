

## C++基础

#### 内存结构。

1. 栈

   编译器和操作系统自动完成内存空间的分配和释放。 

   比如声明的变量等，容量有限，无法手动销毁。

2. 堆

   主动申请的内存(malloc/free), 空闲地址被记录在一个链表中，需要时被分配。

   分配速度慢，地址不连续，容易碎片化，容易造成内存泄漏。

3. 自由储存区

   管理机制和堆类似；

   堆是操作系统维护的一块内存，而自由存储是C++中通过new与delete动态分配和释放对象的抽象概念。堆与自由存储区并不等价。

4. 全局区（静态区）

   全局变量， static 变量。

5. 常量存储区

   储存常量，字符串，const等

![image-20220628174418456](/Users/whz/Library/Application Support/typora-user-images/image-20220628174418456.png)

![image-20220717201648207](/Users/whz/Library/Application Support/typora-user-images/image-20220717201648207.png)

**Code Segment（代码区）**

也称Text Segment，存放可执行程序的机器码。

**Data Segment (数据区）**

存放已初始化的全局和静态变量， 常量数据（如字符串常量）。就是我们上述提到的常量区+ 全局区。

**BSS（Block started by symbol)**

存放未初始化的全局和静态变量。（默认设为0）

**堆/栈**

就是我们之前提到的

#### 内存释放顺序：

创建顺序为从上到下

释放顺序：

相同变量类型，先声明的后释放。不同变量类型，释放顺序与位置无关，与变量类型有关

首先 先释放局部变量 然后是全局变量

同时 普通变量先于静态变量 （局部静态 也是先于 全局普通的）

----

#### 内存泄漏

C++内存管理中内存泄露（memory leak）一般指的是程序在申请内存后，无法释放已经申请的内存空间，内存泄露的积累往往会导致内存溢出。

1. 在类的构造函数和析构函数中没有匹配的调用new和delete函数

   比如：在堆里创建了对象占用了内存，但是没有显示地释放对象占用的内存/ 在类的构造函数中动态的分配了内存，但是在析构函数中没有释放内存或者没有正确的释放内存

2. 两次释放相同的内存

3. 没有将基类的析构函数定义为虚函数

   当基类指针指向子类对象时，如果基类的析构函数不是虚函数，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露。

---

#### 内存对齐

内存对齐是为了让数据在内存中的结构更统一，便于读取。

内存对齐的大小不一定，一般为4

可以用#pragma pack(n)宏去更改

例如一个结构体：

```
struct A
{
    int i;
    char c1;
    char c2;
};
```

所需的内存大小为8

而下面这

```
struct A
{
    char c1;
    int i;
    char c2;
};
```

则为12

当成员中存在static静态变量时, 他不算入sizeof的大小

---

#### 构造函数 析构函数

##### 1.构造函数

构造函数的通用格式

```
Test(int nn, double dd, char cc) 
        : d(dd), n(nn), c(cc) 
    {
        n = 10;
        d = 3.4;
        c = 'b';
    }
```

也就是 函数名(参数列表): 成员变量1(初始值1),...,成员变量n(初始值n){ 函数体赋值 }；

你可以省略参数略表 直接用常量进行初始值和赋值，也可以省略初始值，更可以省略函数体，自由度非常高。

拷贝构造函数，是指在构造函数参数列表中传入一个同类型的函数变量，C++为我们提供了默认的拷贝构造函数

类中默认的拷贝构造函数，实现的是逐个复制非静态成员(成员的复制称为浅复制)值，复制的是成员的值，这种类中默认的拷贝构造函数实现的过程被称为浅拷贝。

比如当我们类成员中含有指针的时候，这时候复制的和被复制的成员中的指针就会指向同一个变量，在释放时，就会产生内存泄漏。

所以一般我们会重写拷贝构造函数，尤其是含有指针等信息的时候。

##### 2.析构函数

形式是构造函数名字前面加一个 “~”

析构函数只有一个没有重载, 析构函数也没有形参

有些特殊情况我们会重写析构函数

例如我们在成员变量中有一个指针数组

这时候如果不重写析构函数，c++只会释放当前数组中指针的内存，而指针指向值的内存还是存在，造成内存泄漏。

##### 3.执行顺序

当建立一个对象时，首先调用基类的构造函数，然后调用下一个派生类的构造函数，依次类推，直至到达最底层的目标派生类的构造函数为止。

当删除一个对象时，首先调用该派生类的析构函数，然后调用上一层基类的析构函数，依次类推，直到到达最顶层的基类的析构函数为止

##### 4.override关键字

在子类你想要重写的函数上可以加上这个关键字 来告诉编译器你想要重写一个函数 而不是新增一个函数 如果在父类中找不到对应的函数 就会报错

---

#### 虚函数

为了实现C++的多态，C++使用了一种动态绑定的技术，也就是关键字virtual。这个技术的核心是虚函数表。

比如 当我我有一个父类A，和一个集成了A的子类B

A中有一个函数 test( cout << 1 << endl);

B中重写了这个函数  test( cout << 2 << endl);

这是 如果我这样创建了一个指针p：

```
A* p = new B();
```

这时候，调用p->test() 会返回 1

如果你在A中将A声明为virtual，则会返回2

这就是虚函数表实现的多态。

##### 析构虚函数

通过基类的指针来删除派生类的对象时，基类的析构函数应该是虚的。

如果不是，后果是对象的派生部分不会被销毁，然而，基类部分很可能已被销毁，这就导致产生了“部分析构”的情况，这是一个内存泄露。

##### 虚函数表

在说虚函数表前，有个关于c++类的很关键的点.

在计算c++某个类的对象占用的大小的时候，我们是不计算成员函数的，这是因为这些成员函数被放在了代码区中，每次需要被调用时就会去代码区找到对应的地址，然后执行。

所以，一个类的函数某个函数是怎么样，是在编译代码的时候就决定的，因为这时候就确定了这个函数被放在代码区的哪个位置。在调用的时候，我们会根据编译时记录下的位置去找到该函数。

这就解释了为什么如果不使用虚函数，就无法实现多态.

我们还是假设A类是基类，B类是父类。

在我们使用A* p = new B(); 时

p这个指针，指向的对象的成员函数，在编译的时候就已经被确定了，他会被指向A的成员函数，而不是B的。

那么 为什么加上一个虚函数的标志 virtual，就可以实现多态呢。

这里就要说虚函数底层的实现 虚函数表

当某个类中含有虚函数的时候，这个类就会添加上一个隐藏的指针，被叫做虚函数表指针，被指向一个虚函数表，这个虚函数表中，记录了所有虚函数的地址。

当子类重写了一个虚函数的时候，该虚函数表中记录的地址就会改变。

再来看这段代码

A* p = new B()；

在编译初期，c++并不会置顶该虚函数指针指向的地址，而是在运行的时候，根据后续传入的值来赋值，因为这个虚函数指针，本质是一个函数成员变量，被放在堆或者栈区中，是在运行的时候再确定的，也就是说，在运行的时候，再来决定这个变量的虚函数表对应的是哪一张表，这样就能实现多态。

#### 多继承虚函数

在多继承情况下，有多少个基类就有多少个虚函数表指针，前提是基类要有虚函数才算上这个基类。

多继承中 要注意一些问题：

当两个或多个基类中有同名的成员时，如果直接访问该成员，就会产生命名冲突，编译器不知道使用哪个基类的成员。这个时候需要在成员名字前面加上类名和域解析符`::`，以显式地指明到底使用哪个类的成员，消除二义性。

再多继承的多态中，如果用一个父类的引用类型来接受一个子类，那么只能调用该子类中重写父类的函数 例如：

A类有f1虚函数 B类有f2虚函数 C类继承AB，并且重写了这两个函数 现有C c;

如有 A& a = c; 那么 通过a 只能调用c中重写的f1函数

同理 如果是B& b = c; 那么只能调用f2函数

在内存模型中 C类是从A类开始，然后再是B类，A类的内存中包含了A的虚指针，B的内存中包含了B的虚指针，同时，在虚函数表中，AB虚指针指向位置的间隔中，还会记录下B相对于整个C类内存的偏移量，这样当我们用B的引用指向c时，就会先将this指针移动到内存偏移处，然后继续。（https://zhuanlan.zhihu.com/p/41309205）

棱形继承：

![image-20220728154247780](/Users/whz/Library/Application Support/typora-user-images/image-20220728154247780.png)

这样会造成数据的冗余和多重含义

如何解决: 使用虚拟继承 虚继承会让类的变量在棱形继承时只保留一份

假设derived 继承自base类，那么derived与base是一种“is a”的关系，即derived类是base类，而反之错误；

假设derived 虚继承自base类，那么derivd与base是一种“has a”的关系，即derived类有一个指向base类的vptr。

也就是说 虚继承的类相当于额外拥有一个基类的对象 而在虚函数表中 我们额外用一块内存记录了这个对象的位置

```C++
class Father
        {
        public:
            virtual void show()
            {
                cout<<"this is Father"<<endl;
            }
        };

class Son:public Father
        {
        public:
            virtual void show()
            {
                cout<<"this is Son"<<endl;
            }
        };

int main(){
    Son son;
    Son* p1 = &son;
    p1->show();
    Father* p2 = static_cast<Father*>(p1);
    p2->show();
}
```

两次输出都会是son 说明就算进行了强转 内容也不会发生变化

但如果如下

```C++
int main(){
    Son son;

    Father f = (Father)son;
    f.show();

}
```

输出的就会是father 

---

#### 智能指针

智能指针就是帮我们C++程序员管理动态分配的内存的，它会帮助我们自动释放new出来的内存，从而**避免内存泄漏**！

1. C++98 提供了 auto_ptr 模板的解决方案
2. C++11 增加unique_ptr、shared_ptr 和weak_ptr

#### 1. auto_ptr

auto_ptr<class_name> test(new class_name);

// 下面这种用法是错误的

// 因为不能直接从普通指针转换到只能指针

// auto_ptr<class_name> p1 = new class_name();

综上 智能指针的创建为auto_ptr<指针要指向的类名> 指针变量名(传入指向的对象的指针)

只能指针本质是维护了一个普通指针的对象

之所以可以像普通指针一样使用 是因为他重写了.和->两个运算符

**get**() 获取智能指针托管的指针地址

```
auto_ptr<class_name> test(new class_name);
class_name* p = test.get();
```

**release**() 取消智能指针对动态内存的托管

```
auto_ptr<class_name> test(new class_name);
class_name* p = test.release();
delete p;
```

**reset**() 重置智能指针托管的内存地址

**auto_ptr 被C++11抛弃**

C++11 后auto_ptr 已经被“抛弃”，已使用unique_ptr替代！C++11后不建议使用auto_ptr。

```
// auto_ptr 被C++11抛弃的主要原因
auto_ptr<string> p1(new string("I'm Li Ming!"));
auto_ptr<string> p2(new string("I'm age 22."));

cout << "p1：" << p1.get() << endl;
cout << "p2：" << p2.get() << endl;

// p2赋值给p1后，首先p1会先将自己原先托管的指针释放掉，然后接收托管p2所托管的指针，
// 然后p2所托管的指针制NULL，也就是p1托管了p2托管的指针，而p2放弃了托管。
p1 = p2;	
cout << "p1 = p2 赋值后：" << endl;
cout << "p1：" << p1.get() << endl;
cout << "p2：" << p2.get() << endl;
```

换句话说 auto_ptr不能进行赋值操作

所以他也不能和stl兼容，因为不能复制的话，会导致stl中的操作无法进行

同时 他不支持对象数组的内存管理

综上 在cpp11中 他被抛弃了

#### 2. unique_ptr

unique_ptr 是 auto_ptr的改进版

无法进行左值复制赋值操作，但允许临时右值赋值构造和赋值

在容器中保存指针是安全的

同时 也支持了对数组的操作

要注意一点

在unique_ptr中 一个智能指针只能维护一个对象，当你将一个已经有智能指针在管理的对象再次交给另一个智能指针管理时，他会自动取消原先的的托管。容易导致内存异常。

当然 之前也提到了 unique_ptr为了避免这一点 特地禁用了左值赋值

但也是有方法更改的

比如

```
unique_ptr<string> p3(p2);	// 禁止左值赋值构造
unique_ptr<string> p3(std::move(p1)); //这样就可以
```

使用了一个move 让它变成了一个右值

#### 3. shared_ptr

shared_ptr 用于解决unique_ptr的排他性问题

也就是可以把一个指针 或者说地址 交给多个shared_ptr来维护

Shared_ptr 实现的原理是：为一块地址或者说指针添加了**引用计数**， 当复制或拷贝时，**引用计数**加1，当智能指针析构时，**引用计数**减1，如果计数为零，代表已经没有指针指向这块内存，那么我们就释放它

```
shared_ptr<string> p1(new string("1234"));
p1.use_count(); //返回有多少个智能指针在管理同一个内存
shared_ptr<string> p2(p1); //共享指针可以直接用拷贝构造函数，也可以直接赋值

//使用make_shared 初始化对象，分配内存效率更高(推荐使用)
shared_ptr<int> up3 = make_shared<int>(2);
```

循环引用问题： 使用share指针的时候 要小心两个指针的对象相互使用了另一个指针，造成类似死锁的情况

空悬指针问题：有两个指针p1和p2，指向堆上的同一个对象Object，p1和p2位于不同的线程中。假设线程A通过p1指针将对象销毁了（尽管把p1置为了NULL），那p2就成了空悬指针

shared_ptr底层的引用计数的实现原理 所有维护同一个指针的shared_ptr 共用一个指向sp_counted_impl_p的指针 从而实现共享的目的

![image-20220720133849841](/Users/whz/Library/Application Support/typora-user-images/image-20220720133849841.png)

#### 4. weak_ptr

弱指针

弱指针和共享指针一样 可以指向已经有其他共享指针管理的对象。

但是，weak_ptr 指针并不会使所指堆内存的引用计数加 1；同样，当 weak_ptr 指针被释放时，之前所指堆内存的引用计数也不会因此而减 1。也就是说，weak_ptr 类型指针并不会影响所指堆内存空间的引用计数。

同样的 他并不能通过.或者->来对指针的内容进行修改

它存在的目的只是比如查看某个指针被引用了多少次，这类的问题

用weak_ptr就能很好的结局上面所提到的循环引用问题

expired()：判断当前 weak_ptr 指针为否过期（指针为空，或者指向的堆内存已经被释放）。

lock()：如果当前 weak_ptr 已经过期，则该函数会返回一个空的 shared_ptr 指针；反之，该函数返回一个和当前 weak_ptr 指向相同的 shared_ptr 指针。

过期的意思是 该弱指针指向的资源已经被释放。

---

#### 异常体系

---

#### 左右值 右值引用

- 左值是可寻址的变量，有持久性；

- 右值一般是不可寻址的常量，或在表达式求值过程中创建的无名临时对象，短暂性的。

- 左值引用：引用一个对象；

  右值引用：就是必须绑定到右值的引用，C++11中右值引用可以实现“移动语义”，通过 && 获得右值引用。

这里有一个问题 如果有如下代码

```
int a = 1;
int b = a;
```

那么在 int b = a 中, a是左值还是右值。

其实在这个运算过程中，c++会先把a的值取出来，然后放在内存中，在把该值作为一个右值赋值给左值b。

但是 a，或者说我们定义的变量a，他仍然是个左值。

只不过在这里，编译器帮我们多做了一步，让他可以当作一个右值来用。

//////////////////////////////////////////////////////////////////////////////////////

传统C++中，右值只有被存储在`const`变量时，才能获取其地址。或者说， 我们只能绑定常量左值到右值。就像下面这样：

```
int& x = 666; // Error
const int& x = 666; // OK
```

move函数，可以把一个左值转化为右值

```
int  &&rr1 = 42;
int  &&rr3 = std::move(rr1);
```

右值引用的一个很常见的用法 就是移动构造函数。

和普通拷贝构造函数的区别是，在拷贝构造函数中，我们传入一个同类型变量的引用，然后手动申请所需的成员变量，再把该引用的值赋给新申请的成员变量。

现在 我们一共有两个同类型的变量，各自拥有不同的内存。

但是，假设一种情况，我们先从某个函数中获得了返回值A，然后我们想将其插入到一个容器中。

假设我们用拷贝构造函数的形式将A插入到容器中，这时候，容器中的变量和外部的A是两个各自不同的变量，然而，外部的A在以后已经不会再被用到了，换句话说，我们是新开了一块空间给A，这样未免有些浪费，为什么不能直接把A的内存交给容器中，避免了新开一块内存的浪费呢。

于是就有了移动构造函数。

移动构造函数的本质是，传入一个右值引用，然后直接将该右值引用赋给新的变量，再把原本右值引用置空防止二次删除。

在这个过程中，我们没有新开内存，而是实现了内存的交换，通过右值引用。

##### 一个很常见的例子

很多情况下 我们会在函数中生成一个类，然后返回他，再用一个值去接收他

像这样

```c++
f(){
  return A();
}
int main(){
  A b = f();
}
```

这种情况 实际上是调用了两次拷贝构造函数 ，因为拷贝构造函数中，我们传入的是一个引用，而传统c++中 是不存在一个对右值（f（））的引用的，所以编译器会这么做：

调用一次拷贝构造函数，拷贝一份A（）产生的值 然后作为返回值

然后将刚刚的返回值 再一次拷贝构造 给b

所以就调用了两次拷贝构造函数.

这里如果用了移动构造函数，将右值直接作为右值引用传入，就可以节约内存。

-------

----

----

分割线

-----

----

---

#### 更深层的move 左右值理解

![image-20220721164210905](/Users/whz/Library/Application Support/typora-user-images/image-20220721164210905.png)

xvalue包括函数的返回值 成员对象的获取 以及move的返回 ，是一个很快就会消亡的值

lvalue就是传统意义上的lvalue

prvalue  **prvalue就是用于计算的或者用于初始化对象的，p代表的是Pure** 包括表达式 1，1+1，“ABC”, &a , a+b 这类 prvalue在结束时会返回一个xvalue 也就是临时变量 这个转化是通过如下方式来实现的：

![image-20220721165343347](/Users/whz/Library/Application Support/typora-user-images/image-20220721165343347.png)

这样就不难解释为什么int a& = 1 这样的表达式会报错 我们怎么能把一个临时值取引用呢？

构造函数的调用情况

- prvalue初始化glvalue，是直接构建，不用调用拷贝或移动构造函数；
- xvalue初始化lvalue，会调用移动函数，也就是move；
- lvalue初始化lvalue，会调用拷贝构造函数。

```c++
int main() {
  gI = 0;
  std::cout << gI << "-";
  Book bb = Book(); // prvalue直接初始化 default constructor
  gI = 1;
  std::cout << gI << "-";
  Book b; //  default constructor
  gI = 2;
  std::cout << gI << "-";
  b = Book(); // 移动 pravlue

  gI = 3;
  std::cout << gI << "-";
  bb = std::move(b); // lvalue转换成xvalue，然后移动
}


////这里还有一个例子
    int  rr1 = 42;
    int  rr2 = std::move(rr1);
    int  &&rr3 = std::move(rr1);
    cout << rr1 << " " << rr2 << " " << rr3 << endl;
    cout << &rr1 << " " << &rr2 << " " << &rr3 << endl;
///结果如下
42 42 42
0x16ce0f574 0x16ce0f570 0x16ce0f574
//  不难看出 rr3和rr1共用了同一个地址 但是三个数的值都是42
//  但如果用了string会发现
    std::string s =" hell world";
    auto kk = std::move(s);
    cout << s << endl;
    cout << kk << endl;
// s为空了 这是因为 string本身重写了移动构造函数 而用左值=xvalue的用法 会调用移动构造函数 把原先的值置空
```

----

#### 赋值运算符和拷贝构造函数

当一个变量在被创建时候 用的是拷贝构造函数

赋值时候 用的是赋值运算符重载

比如 A a2 = a1; 这其实是一种隐式的初始化，相当于直接调用了构造函数，所以会使用拷贝构造函数

但是如果这样

A a2；

A2 = a1; 就会调用赋值运算符重载

---

#### 文件 stream

stream也就是流 是cpp为我们提供的一种更高级的IO形式，

 fstream 文件流

sstream 字符流

////////////////////////////////////////////////////////

fstream中有三个主要的流

ofstream：该数据类型表示输出文件流，用于创建文件并向文件写入信息。
ifstream：该数据类型表示输入文件流，用于从文件读取信息。
fstream：该数据类型表示输入和输出文件流，且同时具有 ofstream 和 ifstream 两种功能，这意味着它可以创建文件，向文件写入信息，从文件读取信息。

```c++
fstream.open(filename，打开方式) //用流打开一个文件
打开方式有下面几种
ios::in	读方式打开文件
ios::out	写方式打开文件
ios::trunc	如果此文件已经存在, 就会打开文件之前把文件长度截断为0
ios::app	尾部最加方式(在尾部写入)
ios::ate	文件打开后, 定位到文件尾
ios::binary	二进制方式(默认是文本方式)
  
fstream.is_open() 判断是否打开
fstream.close() 关闭
  
fstream.eof() 判断读取完毕
```

同样的，有关于字符串流的

istringstream是由一个string对象构造而来，从一个string对象读取字符。

ostringstream同样是有一个string对象构造而来，向一个string对象插入字符。

stringstream则是用于C++风格的字符串的输入输出的。

---

#### 更细节的类型

 int8_t      : typedef signed char;
 uint8_t    : typedef unsigned char;
 int16_t    : typedef signed short ;
 uint16_t  : typedef unsigned short ;
 int32_t    : typedef signed int;
 uint32_t  : typedef unsigned int;
 int64_t    : typedef signed  long long;
 uint64_t  : typedef unsigned long long;

---

size_t与ssize_t

size_t主要用于计数，如sizeof函数返回值类型即为size_t。在不同位的机器中所占的位数也不同，size_t是无符号数，ssize_t是有符号数。

在32位机器中定义为：typedef  unsigned int size_t; （4个字节）
在64位机器中定义为：typedef  unsigned long size_t;（8个字节）

#### 泛形

C++ 泛型

基本的使用就是在函数或者类前声明template<class T,class A,...>

然后在函数或者类中就可以直接将T A..作为一种类型来使用

在创建类或者函数时也要传入对应的类型

比如test<int,string>()

或者A<int>* p = new A<int>()

也可以采取默认类型

template<class T = int,class A = string,...>

这样当不传入的时候就会默认类型是int和string

为了传入不同的类型采取不同的措施

可以使用具体化和部分具体化

```
template<typename T1, typename T2>
class Test {
public:
	Test() {
		cout << "T1 and T2" << endl;
	}
};

// 部分具体化
template<typename T1>
class Test<T1, int> {
public:
	Test() {
		cout << "T1 and int" << endl;
	}
};

// 部分具体化
template<typename T2>
class Test<long, T2> {
public:
	Test() {
		cout << "long and T2" << endl;
	}
};

// 全部具体化
template<>
class Test<long, int> {
public:
	Test() {
		cout << "long and int" << endl;
	}
};
```

---

#### 类型转换

## 一、static_case(静态转换)

（1）使用场景

- 在基本数据类型之间转换，如把 int 转换为 char，这种带来安全性问题由程序员来保证；
- 在有类型指针与 void * 之间转换；
- 用于类层次结构中基类和派生类之间指针或引用的转换。
  - 上行转换（派生类---->基类）是安全的；
  - 下行转换（基类---->派生类）由于没有动态类型检查，所以是不安全的。

## 二、dynamic_cast(动态转换)

（1）使用场景

- 用于将一个父类的指针/引用转化为子类的指针/引用（下行转换）。



（2）使用特点

- 基类必须要有虚函数，因为 dynamic_cast 是运行时类型检查，需要运行时类型信息，而这个信息是存储在类的虚函数表中。
- 对于下行转换，dynamic_cast 是安全的（当类型不一致时，转换过来的是空指针），而 static_cast 是不安全的。
- 对指针进行 dynamic_cast，失败返回 NULL，成功返回正常 cast 后的对象指针；对引用进行 dynamic_cast，失败抛出一个异常，成功返回正常 cast 后的对象引用。

## 三、const_cast(常量转换)

（1）使用场景

- 常量指针（或引用）与非常量指针（或引用）之间的转换。



（2）使用特点

- cosnt_cast 是四种类型转换符中唯一可以对常量进行操作的转换符。
- 去除常量性是一个危险的动作，尽量避免使用。

## 四、reinterpret_cast(不相关类型的转换)

> reinterpret 的英文含义有重新转换的含义，就相当于 C 语言中不相关类型的转换,强转。



（1）使用场景

- 用在任意指针（或引用）类型之间的转换。
- 能够将整型转换为指针，也可以把指针转换为整型或数组。



（2）使用特点

- reinterpret_cast 是从底层对数据进行重新解释，依赖具体的平台，可移植性差。
- 不到万不得已，不用使用这个转换符，高危操作。



#### 编译过程

![image-20220717201622875](/Users/whz/Library/Application Support/typora-user-images/image-20220717201622875.png)

#### 运算符重载

#### **位域**

#### 匿名函数

#### 参数列表

---

#### 匿名命名空间

名命名空间的意义
1.匿名命名空间中的符号限于文件内部使用，不需要被外部引用。
2.匿名命名空间效果类似于全局变量和函数加static，但是比C中的static使用范围广，static只能用于修饰函数名变量名，而不能用于修饰一个类型，如struct,class,而匿名命名空间则不局限于这些。
3.匿名命名空间虽然是一种特殊情况，但是用法逻辑上符合整个命名空间的一般原则。

---

#### 枚举 和 union

```
enum tring{
    x1,
    x2,
    x3 = 10,
    x4,
    x5,
    } x1;

int main()
{
    tring x2;
    cout<<x1<<x2<<endl; //0 1
}
```

---

#### 断言

判断一个表达式 如果结果为假 就中断并且输出

assert(表达式)

---

#### C++内存池 以及内存STL分配器

内存池 是一种常见的内存管理手段 主要目的是为了减少一直申请释放内存带来的开销(因为new和alloc运算符是有开销的) 所以会一次性开出一片较大的内存 然后每次需要时就从这一片内存中取

常见的实现方法：申请一块内存 将其按一定大小划分为小块，类似链表的形式，每一块相当于一个节点，用一个数据结构记录其首地址位置以及下一个节点 一个内存池会维护两个这样的链表 一个表示空闲节点 一个表示已使用的节点.

stl的内存分配器allocator, 主要目的就是为了帮助用户来分配和管理内存，以实现简化用户操作的目的。

默认策略为:

1. 当申请的内存大于128bytes时，使用一级分配器从堆中申请内存
2. 申请大小小于128bytes时，使用二级分配器从内存池中取出一块内存 这个内存池由16个不同大小(8-128)的空闲列表组成



----

typeid 关键字

返回type_info类型

type_info.name 返回类名

- 如果想通过基类的指针获得派生类的数据类型，基类必须带有虚函数
- 只能获取对象的实际类型



---



##### 如何让对象只能在栈/堆上建立

栈：将析构函数设为私有

堆：将new运算符设置为私有
