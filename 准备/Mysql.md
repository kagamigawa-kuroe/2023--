## Mysql 八股



##### 数据库三范式

- 第一范式：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项。
- 第二范式：要求实体的属性完全依赖于主关键字。所谓完全 依赖是指不能存在仅依赖主关键字一部分的属性。
- 第三范式：任何非主属性不依赖于其它非主属性。



**数据库设计原则有什么？**

1)一致性原则：对数据来源进行统一、系统的分析与设计，协调好各种数据源，保证数据的一致性和有效性。

2)完整性原则：数据库的完整性是指数据的正确性和相容性。要防止合法用户使用数据库时向数据库加入不合语义的数据。对输入到数据库中的数据要有审核和约束机制。

3)安全性原则：数据库的安全性是指保护数据，防止非法用户使用数据库或合法用户非法使用数据库造成数据泄露、更改或破坏。要有认证和授权机制。

4)可伸缩性与可扩展性原则：数据库结构的设计应充分考虑发展的需要、移植的需要，具有良好的扩展性、伸缩性和适度冗余。

5)规范化原则：数据库的设计应遵循规范化理论。规范化的数据库设计，可以减少数据库插入、删除、修改等操作时的异常和错误，降低数据冗余度等。



##### 引擎

MySQL 支持多种存储引擎,比如 InnoDB,MyISAM,Memory,Archive 等等

InnoDB 支持事务，MyISAM 不支持

InnoDB 是聚集索引，MyISAM 是非聚集索引

MyISAM 采用表级锁(table-level locking)；InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。



超键：在关系中能唯一标识元组的属性集称为关系模式的超键。

外键：在一个表中存在的另一个表的主键称此表的外键。



##### 约束

- NOT NULL: 用于控制字段的内容一定不能为空（NULL）。

- UNIQUE: 控件字段内容不能重复，一个表允许有多个 Unique 约束。

- PRIMARY KEY: 也是用于控件字段内容不能重复，但它在一个表只允许出现一个。

  

##### varchar 和 char 有什么区别?

一个定长 一个变长



##### in 和 exists 区别

in语句是把外表和内表作hash 连接 / exists语句是对外表作loop循环，每次loop循环再对内表进行查询

子查询表大的用exists，子查询表小的用in



##### drop、delete与truncate的区别

![image-20230208174326098](/Users/whz/Library/Application Support/typora-user-images/image-20230208174326098.png)

##### mysql执行过程

1. 客户端通过 TCP 连接发送连接请求到 MySQL 连接器，连接器会对该请求进行权限验证及连接资源分配
2. 查缓存。（当判断缓存是否命中时，MySQL 不会进行解析查询语句，而是直接使用 SQL 语句和客户端发送过来的其他原始信息。所以，任何字符上的不同，例如空格、注解等都会导致缓存的不命中。）
3. 语法分析（SQL 语法是否写错了）。 如何把语句给到预处理器，检查数据表和数据列是否存在，解析别名看是否存在歧义。
4. 优化。是否使用索引，生成执行计划。
5. 交给执行器，将数据保存到结果集中，同时会逐步将数据缓存到查询缓存中，最终将结果集返回给客户端。



#### mysql底层数据结构

Mysql底层使用的是B+树, B+树是一种基于B树变种的多路平衡树，和B树主要的区别有 B+树的节点全部储存在叶子中 上方节点只储存用于判断的数据，同时 所有的叶子节点使用链表进行连接。

之所以使用B+树 原因有如下几个：

1. B+树的所有数据都储存在叶子中 查找时间相对比较稳定
2. innoDB的最小单位为表(16k 可能包含几百条数据记录)，树的一个节点就代表着一个表，B+树的非叶子节点不储存信息 如果采用B树 那么你想要查询的数据可能储存在非叶子节点中 这是在查找过程中 你每路经一个节点 就要从磁盘I/O读取表信息 进行查看 这样效率是非常低的 而如果使用了B+树 中间节点不储存信息 这样无论如何只会在到叶子的时候再查看 效率就会更高。
3. 同时 如果中间的节点不储存表的信息 那么就会有更多的剩余空间 就可以加入更多的判断信息 这样每一层能有的节点数量就会更多 这就导致了B+树会比B树更扁平 平均查找时间就会更短。

---

#### mysql索引

**聚集索引**：首先所谓聚集的含义是索引与data数据是否**相邻**，就是我找到索引以后在它**附近**就可以找到想要的data数据这就是聚集索引。

**非聚集索引**：非聚集索引就是我找到索引后，在它的附近找不到data数据。 叶子节点不包含记录的全部数据。 叶子节点中索引行中还包含了一个书签，用来告诉 InnoDB 存储引擎在哪里可以找到与索引相应的行数据。 这个书签就是相应的行数据的聚集索引键

在mysql中 主键就是聚集索引 非主健就是非聚集索引

换句话说 在底层的B+树中 判断的条件就会是主健 在主健找到的情况下 再去看打开整个表 寻找副键对应的情况

注意 一个表只能有一个主键

当我们先要针对非主键进行查找的时候 就需要用到索引

当我们为某个字段添加了索引之后 会构建一个新的B+树 用于根据这个索引来查找变量

**联合索引** 当我们需要的索引很多 每次添加一个都会新增一棵树 这样做显然不科学

于是就有了联合索引 就可以在同一颗树中用多个字段作为索引

联合索引的本质是 在主键构成B+树中 叶子节点并不会直接存储数据 而是根据我们联合的所有节点进行一个分类 然后根据不同分类开新的树 并且告诉你他的地址 然后我们去改地址继续按照条件查找

![image-20220720153134831](/Users/whz/Library/Application Support/typora-user-images/image-20220720153134831.png)



#### 索引的类型有哪些?



MySQL主要的索引类型主要有FULLTEXT，HASH，BTREE，RTREE。

FULLTEXT

FULLTEXT即全文索引，MyISAM存储引擎和InnoDB存储引擎在MySQL5.6.4以上版本支持全文索引，一般用于查找文本中的关键字，而不是直接比较是否相等，多在CHAR，VARCHAR，TAXT等数据类型上创建全文索引。全文索引主要是用来解决WHERE name LIKE "%zhang%"等针对文本的模糊查询效率低的问题。

HASH

HASH即哈希索引，哈希索引多用于等值查询，时间复杂夫为o(1)，效率非常高，但不支持排序、范围查询及模糊查询等。



##### 什么是前缀索引？
前缀索引是指对文本或者字符串的前几个字符建立索引，这样索引的长度更短，查询速度更快。

使用场景：前缀的区分度比较高的情况下。



**左前缀原则** 

![image-20220720151003956](/Users/whz/Library/Application Support/typora-user-images/image-20220720151003956.png)

**索引覆盖**

索引覆盖就是用索引字段来覆盖要查询的字段 在我们创建索引的时候 将一些数据也加入到索引树中 以避免回表查询 / 使用联合索引就是一种做法

当我们想要查询的字段并没有进行索引的情况 就需要回表 就是从普通索引中找不全所要查询的所有字段，那么需要回表再去主键聚簇索引中寻找，因为聚簇索引中有全量的data数据

这样就会导致效率低下

如果是 select name,age,add from student where name=‘张三’ and age=20；这个时候如果联合索引只有name，age两个字段，没有add字段，所以这种情况又要**回表**查询

sql语句要尽可能的**查询出少量**的字段，就是用哪个字段就查询哪个字段



**索引下推**

`索引下推`的**下推**其实就是指将部分上层（服务层）负责的事情，交给了下层（引擎层）去处理。

在mysql5.6之后的特性

如果where条件中该有多个限制条件**where condition1 and condition2 and condition3**

如果我们为condition1和condirtion2添加了联合索引 但是没有condition3

在5.6以前 引擎层会把所有的满足c1和c2的返回给server层 然后再做判断

但是现在 会直接在引擎层中进行过滤 减少开销



##### 索引失效

1、在使用不等于！= 或者<> 这样的会失效。
2、在使用不包含 not in ， 不存在 not exists 这样的会失效。
3、在使用空 is null，不为空 is not null 这样的会失效。
4、在使用小于 <、大于 >、<=、 >= 这些的时候，mysql优化器会根据索引比例、表的数据量大小等因素来决定走不走索引。

1. 不要在索引列上进行运算或使用函数
2. 前导模糊查询不会使用索引，例如 like %李
3. 负向条件索引不会使用索引，建议用in。负向条件有：!=、<>、not in、not exists、not like 等

----



#### 数据库事务 ACID

**一致性**（**C**onsistency）:

系统中所有的数据都是符合期望的，且相互关联的数据之间不会产生矛盾

要达成这个目标，需要三方面共同努力来保障。

**原子性**（**A**tomic）：在**同一项业务处理** （即事务）过程中，事务保证了对多个数据的修改，要么同时成功，要么同时被撤销

**隔离性**（**I**solation）：在**不同的业务处理**过程中，事务保证了各自业务正在读、写的数据互相独立，不会彼此影响

**持久性**（**D**urability）：事务应当保证所有成功被提交的数据修改都能够正确地被持久化，不丢失

以上几点能保证**本地事务** 即一个数据源 一个服务 过程中的事务，这种情况相对来说比较简单，如果是多个数据源 一个服务(**全局事务**) 或者 多个服务 一个数据源(**共享事务**) 这两种情况 就会比现在的ACID更为复杂 

而更复杂的还有**分布式事务** 即多个服务 多个数据源 这种情况在当前分布式微服务流行的环境下也很常见。

---

##### 先说说mysql本身隔离机制

mysql提供了四个级别的隔离类型 从高到低依次为

- 序列化(SERIALIZABLE)
- 可重复读(REPEATABLE READ)
- 提交读(READ COMMITTED)
- 未提交读(READ UNCOMMITTED)

解决下面这些问题

- 脏读：读到了别的事务过程中的数据 这些数据可能会被该事务再次修改 不安全
- 不可重复读：指的是在同一事务内，不同的时刻读到的同一批数据可能是不一样的 针对update操作
- 幻读：幻读是针对数据**插入（INSERT）**操作来说的 指在同一事务中 别的事务对你的数据进行了insert 或者 delete看起来你的数据变多或者变少了

可以看出这三个问题是依次精确的 脏读是你在修改的时候会被别人读 而不可重复读是你在修改的时候会被别人修改原有的数据 而幻读则是你在修改的时候直接被别人新增或者删除了数据。



隔离级别	实现方式
未提交读	总是读取最新的数据，无需加锁
提交读	读取数据时加共享锁，读取数据后释放共享锁
可重复读	读取数据时加共享锁，事务结束后释放共享锁
串行化	锁定整个范围的键，一直持有锁直到事务结束

----

##### 本地事务

本地事务要考虑的只是单纯的ACID 

常见的问题有几种情况:

- **在一个事务中** 程序对数据库进行修改 改到一半 发生了崩溃了 那么就应该**回溯** 将数据库中的数据恢复到之前的状态
- **在一个事务中** 程序已经完成了事务 但是数据库的改动还没有完全被写入 数据库崩溃 这是 就应该将之前的操作再次进行 恢复到程序结束后应有的状态

为了保证原子性和持久性，就只能在崩溃后采取恢复的补救措施，这种数据恢复操作被称为“崩溃恢复”

为了能够实现崩溃恢复 最好的办法就是采用日志的形式 将所经历的过程全部采用日志的形式记录下来 这样一旦当我们想要恢复的时候 直接采用查看日志 然后处理的方法即可 这个方法又叫做**Commit Logging **

这种办法的主要操作是 在一个事务中 不论你对数据库进行了什么操作 **在事务结束前 都不会被写进数据库中** 而是全部被记录到log文件中 知道事务结束 log文件后会追加一条**提交记录 Commit Record** 这意味着事务已经结束 这是数据库才正式开始对数据进行修改 再修改完后 数据库会在log中再追加一条**结束记录End Record** 代表修改完成

一旦数据库崩溃 再次启动后就会找到最后一条EndRecord的位置 将这之后的操作全部重做 从而实现恢复

不难看出 **Commit Logging**保证了ACID可行性 但是不能提前做一些操作 会导致效率低下

改进方案：**提前写入Write-Ahead** 它可以根据一下条件分为几类

根据**事务提交后 是否要立刻写入** 分为 Force 和 No-force

根据**事务提交前 是否允许提前写入** 分为 steal和 No-steal

Commit Logging 允许 NO-FORCE，但不允许 STEAL。

Write-Ahead 则也允许STEAL

Write-Ahead 给出的解决办法是增加了另一种被称为 Undo Log 的日志类型，当变动数据写入磁盘前，必须先记录 Undo Log，注明修改了哪个位置的数据、从什么值改成什么值，等等 这又被叫做回滚日志

对比一下 Commit Logging为 **开始事务 写入log 提交记录 写入数据库 结束记录**

而 Write-Ahead **开始事务 写入log 写入undolog 执行undolog内容 undolog结束 继续写入log 写入undolog** 加入undolog的意义在于 一旦日前写入 再崩溃之前 这些写入的内容就成了错误 无法会回复 如果有记录记录了已有的undolog 就可以将其恢复.

---

##### mysql的redo Log,undo Log,bin Log

**undolog** 就是上述说到的

**redolog** 因为mysql的updata操作 需要在全磁盘查找 然后更改 第二次updata的时候 又要全磁盘读取 这样效率不是很低的

于是就有了redolog 先将记录写到 redo log 中，并更新内存，这个时候更新就算完成了，操作内存比操作磁盘要快的多。同时，InnoDB 会在适当的时候，将 redo log 中的记录更新到磁盘文件中

redolog是循环的 一旦满了 就从头擦出然后继续写。

**binlog** redo log 是InnoDB 引擎特有的；而 binlog 是MySQL Server 层实现的 

redo log 是物理日志，记录的是“在某个数据页做了什么修改”；而 binlog 是逻辑日志，记录的是语句的原始逻辑。比如 `update T set c=c+1 where ID=2;`这条SQL，redo log 中记录的是 ：`xx页号，xx偏移量的数据修改为xxx；`binlog 中记录的是：`id = 2 这一行的 c 字段 +1`

----

##### 全局事务

当一个服务要再**一次事务**中对**多个数据库**进行修改 就是我们所说的全局事务

如果单纯的用begin三次 和 commit三次 当然是不行的 因为提交也是有先后顺序的

所以 这时候我们需要采用一个叫“两段式提交”的方法

之所以叫两段式提交 因为整个过程分为两段：

- **准备阶段**：又叫作投票阶段 协调者询问事务的所有参与者是否准备好提交，
- **提交阶段**：当所有参与者都准备的时候 我们才会正式提交 当有一个没有准备好 或者超时未回复 就会将所有的操作回滚

---

#### MVCC和undo_log

数据库中无锁实现并发控制的方案 在这种情况下 一个事务中 他只会读取事务开始前一刻快照的信息

undo log是Mysql中比较重要的事务日志之一，顾名思义，undo log是一种用于回退的日志，在事务没提交之前，MySQL会先记录更新前的数据到 undo log日志文件里面，当事务回滚时或者数据库崩溃时，可以利用 undo log来进行回退。

每开启一个事务，我们都会从数据库中获得一个事务 ID（也就是事务版本号），这个事务 ID 是自增长的，通过 ID 大小，我们就可以判断事务的时间顺序。

一个数据默认有两条隐藏的字段

- `DB_TRX_ID`：6-byte，操作这个数据的事务 ID，也就是最后一个对该数据进行插入或更新的事务 ID。
- `DB_ROLL_PTR`：7-byte，回滚指针，也就是指向这个记录的 Undo Log 信息。

假设我们有一个事务正在进行 需要进行一次快照读 而另一个数据在快照读前修改了数据 那么此时 可以根据undo_log中的事务id 去判断当前数据是否可读 并且找到最近的可读数据 也就是事务开始前的快照数据。



#### buffer_pool和redo_log

buffer_pool是对磁盘中的数据进行的一层缓存 提高效率

当对数据进行读时 我们直接从pool中读取、

当对数据进行写时 我们将其标志为脏 同时mysql会选择合适的时机替换

redo log 是物理日志，记录了某个数据页做了什么修改，对 XXX 表空间中的 YYY 数据页 ZZZ 偏移量的地方做了AAA 更新，每当执行一个事务就会产生这样的一条物理日志。

这样 就算断电内存pool中的数据丢失 我们也可以根据redolog 确认我们应该做什么



#### binlog

MySQL的 binlog 是记录所有数据库表结构变更（例如 CREATE、ALTER TABLE）以及表数据修改（INSERT、UPDATE、DELETE）的二进制日志。binlog 不会记录 SELECT 和 SHOW 这类操作，因为这类操作对数据本身并没有修改，但你可以通过查询通用日志来查看 MySQL 执行过的所有语句。

![image-20230205205631419](/Users/whz/Library/Application Support/typora-user-images/image-20230205205631419.png)







**分表**

比如你单表都几千万数据了，你确定你能扛住么？绝对不行，单表数据量太大，会极大影响你的 sql执行的性能，到了后面你的 sql 可能就跑的很慢了。一般来说，就以我的经验来看，单表到几百万的时候，性能就会相对差一些了，你就得分表了。

分表就是把一个表的数据放到多个表中，然后查询的时候你就查一个表。比如按照用户 id 来分表，将一个用户的数据就放在一个表中。然后操作的时候你对一个用户就操作那个表就好了。这样可以控制每个表的数据量在可控的范围内，比如每个表就固定在 200 万以内。

**分库**

分库就是你一个库一般我们经验而言，最多支撑到并发 2000，一定要扩容了，而且一个健康的单库并发值你最好保持在每秒 1000 左右，不要太大。那么你可以将一个库的数据拆分到多个库中，访问的时候就访问一个库好了。

这就是所谓的分库分表。





![image-20230208223539403](/Users/whz/Library/Application Support/typora-user-images/image-20230208223539403.png)



索引失效

is not null

!=

like 开头通配符

不符合最左前缀

where中带计算



不适合索引的情况

数据少

区分度低

更新频繁



死锁

1. 查看日志
2. 找出死锁sql



水平分库 分表 按照 hash、range

- 垂直分库：以表为依据，按照业务归属不同，将不同的表拆分到不同的库中。
- 垂直分表：以字段为依据，按照字段的活跃性，将表中字段拆到不同的表（主表和扩展表）中。



Innodb不支持全文索引，而MyISAM支持全文索引

- nnoDB支持事务，MyISAM不支持事务
- InnoDB支持外键，MyISAM不支持外键

- InnoDB支持表、行级锁，而MyISAM支持表级锁。



分布式主键方案

- Redis生成ID
- zookeeper生成唯一ID
- UUID



show processlist 查看mysql进程情况

show status 命令了解各种 sql 的执行频率

通过慢查询日志定位那些执行效率较低的 sql 语句



- Blob用于存储二进制数据，而Text用于存储大字符串。



DECIMAL

salary DECIMAL(9,2)，9(precision)代表将被用于存储值的总的小数位数，而2(scale)代表将被用于存储小数点后的位数

保存金币



权限表有哪些？

user权限表 db权限表 table_priv权限表 table_priv权限表 table_priv权限表

 

binlog 录入格式

statement，每一条会修改数据的sql都会记录在binlog中

row，不记录sql语句上下文相关信息，仅保存哪条记录被修改





1. 插入和删除操作可能涉及到频繁的节点分裂和合并。当插入或删除一个键值时，可能需要将某个节点分裂成两个或多个节点，或者将相邻的节点合并成一个节点。这些操作可能导致磁盘访问的增加，从而降低性能。
2. B+树的实现比较复杂。相比于一些其他数据结构，B+树的实现需要考虑更多的细节，如节点的分裂和合并策略、节点的大小、页的大小等等，这些细节可能对性能产生重大影响。
3. B+树不适合进行随机访问。由于B+树的节点大小通常很大，而每次访问只能获取一个节点的数据，因此随机访问时可能会产生很多的磁盘I/O操作，降低性能。
4. B+树需要占用较多的存储空间。为了保证有序性，B+树中需要存储大量的索引信息，这些索引信息可能比实际的数据占用更多的存储空间。





数据库事务的四个特性（ACID）是：

1. 原子性（Atomicity）：事务中的所有操作要么全部提交成功，要么全部回滚失败。即一个事务中的所有操作必须是“原子”的，不可分割的整体。

原理：当事务执行过程中出现了错误或异常情况，可以使用回滚机制将事务撤销到执行前的状态，保证数据的一致性。

1. 一致性（Consistency）：事务执行前和执行后都必须保证数据的一致性。即一个事务执行完成后，数据库中的数据应该处于一致性状态，符合预期的规则和约束条件。

原理：通过在事务提交前执行数据验证和完整性检查，确保数据的一致性。

1. 隔离性（Isolation）：每个事务的操作都应该与其他事务的操作相互隔离，相互独立。即事务的执行不会被其他事务的执行结果所影响，也不会对其他事务产生影响。

原理：通过使用锁机制和并发控制技术，保证多个事务的并发执行，防止出现数据不一致的情况。

1. 持久性（Durability）：事务提交后，对数据库中的数据所做的修改应该永久保存，不受任何异常情况（如系统崩溃、断电等）的影响。

原理：通过使用日志文件、数据库恢复机制等技术，保证事务提交后的数据持久性和可靠性。

综上所述，ACID特性是数据库事务保证数据正确性、可靠性和安全性的基础。在设计和实现数据库系统时，需要合理地运用这些特性，以保证数据的完整性和一致性，提高系统的可靠性和性能。



```mysql
CREATE TABLE score_table (
  student_id INT PRIMARY KEY,
  student_name VARCHAR(20) NOT NULL,
  score INT NOT NULL
);

INSERT INTO score_table (student_id, student_name, score) VALUES 
  (1, '张三', 85),
  (2, '李四', 92),
  (3, '王五', 88),
  (4, '赵六', 90),
  (5, '钱七', 89);

SELECT student_name FROM score_table ORDER BY score DESC LIMIT 1;
```





MySQL连接器是MySQL服务器的一个重要组件，其主要作用是管理客户端连接并提供连接服务。连接器具有以下几个方面的功能：

1. 连接池：连接器维护了一个连接池，可以复用已经建立的连接，从而减少连接的建立和关闭所带来的开销。连接池中保存了一些已经建立的连接，可以通过对这些连接进行重复利用来满足客户端的连接请求。在连接池中，还可以通过设置最大连接数、最小连接数、空闲连接时间等参数来对连接进行管理。
2. 网络通信：连接器负责和客户端之间的网络通信，通过接收和处理客户端的请求，向客户端发送响应结果。连接器还负责对请求和响应进行压缩和加密等操作，以提高通信的效率和安全性。
3. 用户鉴权：连接器负责对客户端的用户进行鉴权，确定客户端是否具有执行所请求的操作的权限。在客户端建立连接时，连接器会验证客户端提供的用户名和密码是否正确，如果验证通过，则允许客户端进行后续的操作。如果验证失败，则拒绝客户端的请求。
4. 连接状态管理：连接器还负责管理连接的状态，包括连接的建立、关闭、回收等操作。在连接建立后，连接器会为连接分配一个唯一的连接ID，并记录连接的相关信息，包括连接的用户、客户端IP地址、连接时间等。在连接关闭时，连接器会将连接从连接池中移除，并释放连接占用的资源。



##### 日志刷盘时机

在MySQL中，有两种方式可以触发日志刷盘：一种是通过redo log的checkpoint机制，当一定数量的redo log日志记录被写入到磁盘上的redo log文件中时，MySQL会自动将Buffer Pool中的数据页写入到磁盘中；另一种是通过innodb_flush_logs()命令手动刷盘。通常情况下，MySQL会根据系统的负载情况自动触发日志刷盘，以保证数据的一致性和可靠性。





##### 二段式提交

在最后提交事务的时候，需要有3个步骤：

- 写入redo log，处于prepare状态
- 写binlog
- 修改redo log状态为commit ps: redo log的提交分为prepare和commit两个阶段，所以称之为**两阶段提交** 





nextkeylock

行锁+间隙锁 解决了幻读问题





在MySQL数据库中，redo log是一组用于恢复数据的日志文件，它记录了在事务提交之前对数据库所做的所有修改。如果发生故障，如系统崩溃或断电，redo log可以用来重播这些修改并恢复数据库到故障前的状态。

要从故障中恢复，需要执行以下步骤：

1. 确认故障的类型和原因。这可能需要查看MySQL的错误日志和系统日志以获取更多信息。
2. 在MySQL重新启动时，检查InnoDB存储引擎是否已启动redo log的自动恢复过程。如果是，则数据库将自动使用redo log进行恢复。如果没有，请手动启动自动恢复。
3. 如果使用了备份和恢复策略，则可以将最近的备份还原到故障发生之前，并使用redo log来应用从备份到故障发生期间所做的任何更改。
4. 如果没有备份，则需要执行以下步骤来使用redo log进行恢复：

- 确认最后一个已知的正确状态。
- 确认最近一次checkpoint之后的redo log记录。
- 将缺失的数据应用到最后一个已知的正确状态，直到数据库完全恢复。

总之，要从故障中恢复，需要仔细检查redo log，并使用其中记录的信息应用所有丢失的修改，以将数据库恢复到其之前的状态。





##### 意向锁 用于解决表级锁与行级锁的冲突问题

如果我们对于一行数据 先加了互斥锁 再加表级锁

那么在加表级锁的时候 需要遍历表中所有数据 判断有无行级锁

但如果我们使用意向互斥锁时，他与表级锁本身不兼容，就无须进行遍历判断





##### 唯一索引和普通索引的性能差距

读：唯一索引在查找到后直接读如 普通索引会需要继续去找剩下的

  理论上唯一索引会更快一些 但是由于mysql是按页去读数据的 所以加入到内存后其实差的并不多

写 由于唯一索引无法用change buffer 所以会更慢





### 2. count(1) and count(字段)

两者的主要区别是

（1） `count(1)` 会统计表中的所有的记录数，包含字段为null 的记录。

（2） count(字段) 会统计该字段在表中出现的次数，忽略字段为null 的情况。即不统计字段为null 的记录。



统计表的总记录数按照效率排序的话count(字段)<count(主键id)<count1≈count(*)





##### mysql 分页查询优化

子查询优化 加入where限定 如where ID> 100000

**id限定优化** between

**延迟关联** 使用join 现在左表中用索引查询出字段 然后在查询

记录上次查询的位置





#### 2.1.1 Statement

Statement 模式只记录执行的 SQL，不需要记录每一行数据的变化，因此极大的减少了 binlog 的日志量，避免了大量的 IO 操作，提升了系统的性能。

但是，正是由于 Statement 模式只记录 SQL，而如果一些 SQL 中包含了函数，那么可能会出现执行结果不一致的情况。比如说 uuid() 函数，每次执行的时候都会生成一个随机字符串，在 master 中记录了 uuid，当同步到 slave 之后，再次执行，就获取到另外一个结果了。

所以使用 Statement 格式会出现一些数据一致性问题。

#### 2.2.2 Row

从 MySQL5.1.5 版本开始，binlog 引入了 Row 格式，Row 格式不记录 SQL 语句上下文相关信息，仅仅只需要记录某一条记录被修改成什么样子了。

Row 格式的日志内容会非常清楚的记录下每一行数据修改的细节，这样就不会出现 Statement 中存在的那种数据无法被正常复制的情况。

不过 Row 格式也有一个很大的问题，那就是日志量太大了，特别是批量 update、整表 delete、alter 表等操作，由于要记录每一行数据的变化，此时会产生大量的日志，大量的日志也会带来 IO 性能问题。

#### 2.2.3 Mixed

从 MySQL5.1.8 版开始，MySQL 又推出了 Mixed 格式，这种格式实际上就是 Statement 与 Row 的结合。

在 Mixed 模式下，系统会自动判断该用 Statement 还是 Row：一般的语句修改使用 Statement 格式保存 binlog;对于一些 Statement 无法准确完成主从复制的操作，则采用 Row 格式保存 binlog。

Mixed 模式中，MySQL 会根据执行的每一条具体的 SQL 语句来区别对待记录的日志格式，也就是在 Statement 和 Row 之间选择一种。





#### 分页查询优化

1. 索引覆盖

   ```sql
   select * from t5 order by text limit 1000000, 10;
   ```

   在进行分页查询的时候 如果没有做到索引覆盖 会进行回表查询 效率很多 并且在高量级的数据下  mysql优化器甚至会直接全表扫描 不走索引

   综上 我们要尽可能满足索引覆盖的条件

   

2. 子查询优化

   因为实际开发中，用SELECT查询一两列操作是非常少的，因此上述的覆盖索引的适用范围就比较有限。

   ```sql
   select * from t5 where id>=(select id from t5 order by text limit 1000000, 1) limit 10;
   ```

​       子查询优化巧妙的将需要跳过的数据用索引扫过 然后在用自增主键去查询



3. 延迟关联 

   我们可以使用JOIN，先在索引列上完成分页操作，然后再回表获取所需要的列。

   ```sql
   select a.* from t5 a inner join (select id from t5 order by text limit 1000000, 10) b on a.id=b.id;
   ```

   

4. 记录上次的结束位置





#### 分库分表

**分库分表是为了解决由于数据量过大而导致数据库性能降低的问题，将原来独立的数据库拆分成若干数据库组成，将数据大表拆分成若干数据表组成，使得单一数据库、单一数据表的数据量变小，从而达到提升数据性能的目的。**

垂直分表 基于列字段进行的 例如拆分常用和不常用的表

水平分表 按照某种规则（RANGE,HASH取模等）将数据水平切分到不同的表中



垂直分库 垂直分库针对的是一个系统中的不同业务进行拆分，比如用户User一个库，商品Producet一个库，订单Order一个库

水平分库分表 将单张表的数据切分到多个服务器上去



水平分割方法 ： RANGE HASH取模 地理区域 时间





#### 读写分离如何实现

1. 基于程序代码 在代码中根据select、insert进行路由分类
2. 基于中间层代理 MySQL-Proxy 插件等









