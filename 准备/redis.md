1. 

2. 基本类型

   **string** 一个字符串类型键允许存储的数据的最大容量是512MB

   **hashmap**

   **list**

   **set**

   **zset** 有序集合 使用跳表进行存储

   **geospatial** 地理位置

   **bitmap**

   

3. redis快的原因

   完全基于内存操作

   使用单线程模型来处理客户端的请求，避免了上下文的切换

   IO 多路复用机制

   

4. redis **还是使用单线程模型来处理客户端的请求**，只是使用多线程来处理数据的读写和协议解析



4. 持久化方式

   AOF 和 RDB.

   **aof** redis每次执行某个命令的时候 都会将该命令写入到一个备份文件中 

   备份频率高 但是占用的磁盘也多 数据恢复慢

   > always：命令写入aof_buf后，直接调用系统的fsync操作同步到AOF文件。
   > everysec：命令写入aof_buf后，调用系统的write操作，write操作完成后线程返回。fsync同步文件操作由专门线程每秒调用一次。
   > no：命令写入aof_buf后调用系统的write操作，不对AOF文件做fsync同步，同步硬盘操作由操作系统负责，通常同步周期最长30秒。

   **rdp** 把某个时间点的数据直接用二进制的形式储存 类似于快照机制

   大型数据恢复速度快 但是保存的频率更低

   rdb备份过程中 fork一个子进程 去进行备份

   由于使用了copyonwrite机制 就算此时主线程有修改 也不会影响他了

   

5. 过期删除策略

   **定时过期**：**每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除**

   **惰性过期**：只有当**访问一个key时，才会判断该key是否已过期**



##### **定期删除**

定期策略是每隔一段时间执行一次删除过期键的操作，并通过限制删除操作执行的时长和频率来减少删除操作对CPU 时间的影响，同时也减少了内存浪费

Redis 默认会每秒进行 10 次（redis.conf 中通过 hz 配置）过期扫描，扫描并不是遍历过期字典中的所有键，而是采用了如下方法

1. 从过期字典中随机取出 20 个键
2. 删除这 20 个键中过期的键
3. 如果过期键的比例超过 25% ，重复步骤 1 和 2

为了保证扫描不会出现循环过度，导致线程卡死现象，还增加了扫描时间的上限，默认是 25 毫秒（即默认在慢模式下，如果是快模式，扫描上限是 1 毫秒）



可见在 redisDb 结构的 expire 字典（过期字典）保存了所有键的过期时间

过期字典的键是一个指向键空间中的某个键对象的指针

过期字典的值保存了键所指向的[数据库](https://cloud.tencent.com/solution/database?from=10680)键的过期时间



6. 淘汰策略

   1.noeviction：直接返回错误，不淘汰任何已经存在的redis键

   2.allkeys-lru：所有的键使用lru算法进行淘汰

   3.volatile-lru：有过期时间的使用lru算法进行淘汰

   4.allkeys-random：随机删除redis键

   5.volatile-random：随机删除有过期时间的redis键

   6.volatile-ttl：删除快过期的redis键

   7.volatile-lfu：根据lfu算法从有过期时间的键删除

   8.allkeys-lfu：根据lfu算法从所有键删除

   

7. 在Redis中，我们把***\*访问频率高的Key，称为热Key\****

   在redis前加入代理 监测热key

   使用集群分散读请



8. 缓存穿透: 缓存穿透是指用户请求的数据**在缓存中不存在并且在数据库中也不存在**

   使用布隆过滤器

   缓存击穿: 在一个热点缓存失效后 大量的数据直接访问数据库

   保证热点不过期 使用锁

   缓存雪崩：redis因请求太多而崩溃 大量数据直接访问数据库 

   避免大量的缓存的同时失效



9. redis部署方式

   **单机模式**
   
   
   
   **主从模式** 
   
   一个写节点 多个读节点 master节点用于写 挂了会新选举
   
   主从复制 单向复制 从主到从 **bgsave**
   
   a. 全量复制 通过子进程创建RDB文件 将其发送给从节点 进行复制
   
   b. 发送复制的偏移量 将不同的指令发送给从节点
   
   
   
   **哨兵模式**
   
   用于重新选举主节点
   
   **主观下线** 哨兵观测到服务器ping不通
   
   **客观下线** 大部分哨兵都认为服务器挂了
   
   
   
   **集群模式**
   
   多个主节点 多个从节点
   
   
   
10. 一个cluster集群中总共有16384个节点，集群会**将这16384个节点平均分配给每个节点**，当然，我这里的节点指的是每个主节点



11. 数据库一致性

    a. 先更新数据库，后删除缓存 **删除重试机制**

    b. 反过来 容易出现脏读的问题

    

12. Redis的KEYS命令，用于查找所有匹配给定模式 pattern 的 key 



13. SETNX 是SET IF NOT EXISTS的简写.日常命令格式是SETNX key value，如果 key不存在，则SETNX成功返回1，如果这个key已经存在了，则返回0

    可以用来实现分布式锁

    要给锁加上过期时间
    
    // 加锁 SETNX lock_key 1 // 业务逻辑 DO THINGS // 释放锁 DEL lock_key





1. 如何利用MySQL + Redis实现的好友功能？

利用redis的集合set 可以很容易的实现共同好友的功能

`SINTER` 返回给定所有给定集合的交集

`SUNION` 返回给定集合的并集





redis有序集合 采用压缩列表+跳表 数据少的时候用前者 多的时候用后者



线程池七个参数详解

corePoolSize 线程池核心线程大小

maximumPoolSize 线程池最大线程数量

keepAliveTime 空闲线程存活时间

unit 空闲线程存活时间单位

workQueue 工作队列

threadFactory 线程工厂

handler 拒绝策略





# 假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？

使用keys指令可以扫出指定模式的key列表。

**对方接着追问：如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？**

这个时候你要回答redis关键的一个特性：**redis的单线程的。**keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以**使用scan指令，** scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。



底层结构 

hashmap 小的时候用ziplist 打的时候用hashmap

set 小的时候用intset 大的时候用hashmap

zset 小的时候用ziplsit 大的时候用跳表





当Sentinel集群选举出Sentinel Leader后(选举采用raft算法 先到先得)，由Sentinel Leader从redis从节点中选择一个redis节点作为主节点：

- 过滤故障的节点
- 选择优先级`slave-priority`最大的从节点作为主节点，如不存在则继续
- 选择复制偏移量（数据写入量的字节，记录写了多少数据。主服务器会把偏移量同步给从服务器，当主从的偏移量一致，则数据是完全同步）最大的从节点作为主节点，如不存在则继续
- 选择`runid`（redis每次启动的时候生成随机的`runid`作为redis的标识）最小的从节点作为主节点





这些模式是与缓存相关的常见设计模式：

1. Cache-Aside Pattern（旁路缓存模式）：应用程序在访问数据时，首先从缓存中查询数据。如果数据不存在于缓存中，应用程序会从数据源（如数据库）中获取数据，并将数据写入缓存中。此模式中，缓存是一个独立于数据源的中间层。当缓存中的数据过期时，应用程序将再次从数据源中获取数据并刷新缓存。
2. Read-Through Pattern（读取穿透模式）：应用程序查询数据时，首先检查缓存。如果缓存中没有数据，缓存将自动从数据源（如数据库）中获取数据。该模式中，应用程序对缓存完全透明，不需要显式的读取或写入缓存。
3. Write-Through Pattern（写入穿透模式）：应用程序将数据写入缓存时，缓存自动将数据写入数据源（如数据库）。此模式中，缓存和数据源保持一致性，并且写入操作是原子的。
4. Write-Behind Pattern（写入延迟模式）：应用程序将数据写入缓存后，缓存不会立即将数据写入数据源。相反，缓存将数据保留在缓存中，并在后台异步将数据写入数据源。此模式可以提高写入性能并减少数据源的负载。但是，此模式可能导致缓存和数据源之间存在数据不一致性的时间窗口。



#### 主从复制

当我们启动多个 Redis 实例的时候，它们相互之间就可以通过 replicaof，命令形成主库和从库的关系

1. 全量复制

   在第一次建立主从关系的时候 会进行一次全量复制，一般会使用rbd文件进行

   在这个过程中 生成 RDB 文件和传输 RDB 文件 是两个时间瓶颈

   可以用过主 从 从 也就是级连的方式 去复制 缓解主节点的压力

   

2. 增量复制 如果出现网络闪断而进行的恢复复制 就会采取增量复制

   通过偏移量 记录哪些命令需要同步过去 从而进行同步 （实现上采取环形buffer队列）



#### 哨兵leader的选举

当一个 Candidate 节点开始竞选 Leader 时，它会执行如下操作：

给自己投一票；
向其他节点发送投票请求，并等待其他节点的回复；
启动一个计时器，用来判断竞选过程是否超时。
在这个 Candidate 节点等待其他节点返回投票结果的过程中，如果它收到了 Leader 节点的心跳消息，这就表明，此时已经有 Leader 节点被选举出来了。那么，这个 Candidate 节点就会转换为 Follower 节点，而它自己发起的这轮竞选 Leader 投票过程就结束了。

而如果这个 Candidate 节点，收到了超过半数的其他 Follower 节点返回的投票确认消息，也就是说，有超过半数的 Follower 节点都同意这个 Candidate 节点作为 Leader 节点，那么这个 Candidate 节点就会转换为 Leader 节点，从而可以执行 Leader 节点需要运行的流程逻辑。



#### 混合持久化

为了避免aof在重写的过程中缓慢的问题 采用混合持久化 也就是rbd + aof的形式去完成

对于全量的数据 采用rbd的形式保存下来 对于增量的数据 也就是修改 采用aof保存下来 然后替换原本的备份文件

































