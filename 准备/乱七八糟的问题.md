#### 不同种类的上下文切换

- 进程上下文切换
- 线程上下文切换
- 中断上下文切换

**中断上下文切换，并不需要保存和恢复进程的虚拟内存等用户态资源，只需要处理 CPU 寄存器、内核堆栈等内核态的资源即可。**

**进程上下文切换 需要改变最多的内容 包括栈的状态，cpu状态，文件，管道，信号，虚拟内存等，同一进程下的线程切换就好一些，因为栈区是共享的，所以切换更轻量级**





#### 协程的实现原理？无栈协程和有栈协程？独立栈和共享栈？
协程本质是一个用户态的线程，通过跳转来实现

有栈协程把局部变量放在新开的空间上，无栈协程直接使用系统栈使得CPU cache局部性更好，同时也使得无栈协程的中断和函数返回几乎没有区别

通过独立栈实现的协程库中的每一个协程都有自己独立的栈空间，协程栈大小固定且互不干扰
。

通过共享栈实现的协程库中的每一个协程在运行时都使用一个公共的栈空间，当协程挂起时将自己的数据从共享栈拷贝到自己的独立栈，协程运行时又将数据从独立栈拷贝到共享栈运行



####  mmap

正常读写的时候 会经过系统调用 从而将数据拷贝 内核空间和用户空间都有一份相同的数据 造成浪费

mmap系统调用的最终目的是将设备或文件映射到用户进程的虚拟地址空间，实现用户进程对文件的直接读写，



用户空间mmap()函数`void *mmap(void *start, size_t length, int prot, int flags,int fd, off_t offset)`



mmap() 会返回一个指针 ptr，它指向进程逻辑地址空间中的一个地址，这样以后，进程无需再调用 read 或 write 对文件进行读写，而只需要通过 ptr 就能够操作文件。但是 ptr 所指向的是一个逻辑地址，要操作其中的数据，必须通过 MMU 将逻辑地址转换成物理地址，如 图1中过程2 所示。这个过程与内存映射无关。

前面讲过，建立内存映射并没有实际拷贝数据，这时，MMU 在地址映射表中是无法找到与 ptr 相对应的物理地址的，也就是MMU失败，将产生一个缺页中断，缺页中断的中断响应函数会在 swap 中寻找相对应的页面，如果找不到（也就是该文件从来没有被读入内存的情况），则会通过 mmap() 建立的映射关系，从硬盘上将文件读取到物理内存中，如 图1中过程3 所示。这个过程与内存映射无关。

   **mmap内存映射的实现过程，总的来说可以分为三个阶段：**

​    **（一）进程启动映射过程，并在虚拟地址空间中为映射创建虚拟映射区域**

   1、进程在用户空间调用库函数mmap，原型：
      void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);

   2、在当前进程的虚拟地址空间中，寻找一段空闲的满足要求的连续的虚拟地址

   3、为此虚拟区分配一个vm_area_struct结构，接着对这个结构的各个域进行了初始化

   4、将新建的虚拟区结构（vm_area_struct）插入进程的虚拟地址区域链表或树中

   **（二）调用内核空间的系统调用函数mmap（不同于用户空间函数），实现文件物理地址和进程虚拟地址的一一映射关系**

   5、为映射分配了新的虚拟地址区域后，通过待映射的文件指针，在文件描述符表中找到对应的文件描述符，通过文件描述符，链接到内核“已打开文件集”中该文件的文件结构体（struct file），每个文件结构体维护着和这个已打开文件相关各项信息。

   6、通过该文件的文件结构体，链接到file_operations模块，调用内核函数mmap，其原型为：int mmap(struct file *filp, struct vm_area_struct *vma)，不同于用户空间库函数。

   7、内核mmap函数通过虚拟文件系统inode模块定位到文件磁盘物理地址。

   8、通过remap_pfn_range函数建立页表，即实现了文件地址和虚拟地址区域的映射关系。此时，这片虚拟地址并没有任何数据关联到主存中。

**（三）进程发起对这片映射空间的访问，引发缺页异常，实现文件内容到物理内存（主存）的拷贝**

   **注**：前两个阶段仅在于创建虚拟区间并完成地址映射，但是并没有将任何文件数据的拷贝至主存。真正的文件读取是当进程发起读或写操作时。

   9、进程的读或写操作访问虚拟地址空间这一段映射地址，通过查询页表，发现这一段地址并不在物理页面上。因为目前只建立了地址映射，真正的硬盘数据还没有拷贝到内存中，因此引发缺页异常。

   10、缺页异常进行一系列判断，确定无非法操作后，内核发起请求调页过程。

   11、调页过程先在交换缓存空间（swap cache）中寻找需要访问的内存页，如果没有则调用nopage函数把所缺的页从磁盘装入到主存中。

   12、之后进程即可对这片主存进行读或者写的操作，如果写操作改变了其内容，一定时间后系统会自动回写脏页面到对应磁盘地址，也即完成了写入到文件的过程。

   **注**：修改过的脏页面并不会立即更新回文件中，而是有一段时间的延迟，可以调用msync()来强制同步, 这样所写的内容就能立即保存到文件里了。



#### 共享内存

shmget/shmat/shmdt



#### 必须要加上typename的情况

在编译器无法推导的情况下 我们需要使用

```cpp
namespace detail{
    using apply = int;
}

template<class T, class T2> void f_tmpl () { 
    typename T::foo * x; // 这里我们需要typename来告诉编译器T::foo是一个type
    T2::foo * y; // 这里编译器默认T2::foo不是一个type
    T t; // 这里我们不需要typename，编译器也知道T是一个type
    detail::apply a; /* 这里也不需要typename，因为没有template argument
                       一切信息已知，apply 不属于dependent type 
                       所以编译器也知道这里的apply是一个type */
}
```



#### 迭代器失效

对于序列式容器(如vector,deque)，序列式容器就是数组式容器，删除当前的iterator会使后面所有元素的iterator都失效。

链表型数据结构（list） 使用了不连续分配的内存，删除运算使指向删除位置的迭代器失效，但是不会失效其他迭代器







##### 如何设计一个守护进程

1. 在后台运行。 fork后让父进程终止
2. 脱离控制终端，登录会话和进程组 也就是pid sid 使用setsid()系统调用
3. 禁止打开终端 使进程不再成为会话组长来禁止进程重新打开控制终端：结束第一子进程，第二子进程继续（第二子进程不再是会话组长）if(pid=fork()) exit(0);
4. 关闭文件描述符
5. 改变工作目录
6. 处理SIGCHLD信号





##### tcp选项

*TCP 选项*用于窗口缩放、时间戳和选择性ACK



dns 递归查询 迭代查询 ...

 DNS协议使用端口号**53**





#### read 的错误

EINTR 在读取到数据以前调用被信号所中断.

EAGAIN 使用 O_NONBLOCK 标志指定了非阻塞式输入输出,但当前没有数据可读.

EIO 输入输出错误.可能是正处于后台进程组进程试图读取其控制终端,但读操作无效,或者被信号SIGTTIN所阻塞,或者其进程组是孤儿进程组.也可能执行的是读磁盘或者磁带机这样的底层输入输出错误.

EISDIR fd 指向一个目录.

EBADF fd 不是一个合法的文件描述符,或者不是为读操作而打开.

EINVAL fd 所连接的对象不可读.

EFAULT buf 超出用户可访问的地址空间.





## 2.1 bss段

**bss段（bss segment）**通常是指用来存放程序中未初始化（或初始化为0）的全局变量的一块内存区域。

运行时所需要的BSS段大小记录在目标文件中，但BSS段并不占据目标文件的任何空间。

bss是英文Block Started by Symbol的简称。

bss段属于静态内存分配。 

## **2.2 data：**

**数据段（data segment）**通常是指用来存放程序中已初始化(非零)的非const的全局变量的一块内存区域。

数据段属于静态内存分配。 

注：const全局变量一般放到了rodata段，初始化为零的全局变量可能被编译器优化到 bss段





### 一般来说，应该在下面这些列上创建索引

- 在经常搜索的列上创建索引，能够加快搜索的速度；
- 在作为主键的列上创建索引，需要强制该列的唯一性和组织表中数据的排列结构；
- 在经常被用在连接的列上(主要是外键)建立索引，可以加快连接速度。
- 在经常使用`WHERE`子句˜的列上建立索引，加快条件的判断速度。当增加索引时，会提高检索性能，加快条件的判断速度，但是会降低修改性能。





![网络学习笔记：TCP 状态转换图| Max's Blog](http://xiehongfeng100.github.io/images/network/tcp/tcp-state-transition-diagram/tcp-state-transition-diagram.png)



##### 递归查询与迭代查询

主机向本地域名服务器的查询一般都是采用递归查询。

本地域名服务器向根域名服务器的查询的迭代查询。



用户 -> 本地域名服务器 -> 根域名服务器 -> 顶级域名服务器





























##### 海量数据的topk

分治 取每个的topk 合并后再比较topk

小根堆



##### 海量数据的中位数

桶排 例如int 根据最高的8位划分出255个桶 不同的数据进入不同的桶 记录下桶中的数据大小 就可以找到中位数





##### 海量数据的频率topk

对数据取hash 相同的hash归为一类 对每一类用trie或者别的方法统计出现的次数

然后用堆排序





**负载均衡算法**可以分为以下几类：

1. 随机算法：随机选择一台服务器处理请求，适用于负载相对平均的情况。
2. 轮询算法：依次将请求分发给每台服务器，适用于负载相对平均的情况。
3. 加权轮询算法：在轮询算法的基础上，为每台服务器分配不同的权重，适用于服务器负载不均的情况。
4. 最小连接数算法：选择连接数最少的服务器处理请求，适用于负载不均的情况。
5. 最少响应时间算法：选择响应时间最短的服务器处理请求，适用于网络延迟较大的情况。
6. 最短预测时间算法：根据服务器处理请求的历史数据预测其未来响应时间，选择预测时间最短的服务器处理请求。

以下是几种客户端负载均衡算法的对比：

1. 随机算法和轮询算法：简单、易实现，但无法根据服务器负载动态调整权重，适用于负载较为均衡的情况。
2. 加权轮询算法：可以根据服务器负载情况动态调整权重，但无法考虑网络延迟等因素。
3. 最小连接数算法：可以根据服务器负载情况动态调整权重，但无法考虑网络延迟等因素。
4. 最少响应时间算法：考虑了网络延迟等因素，但需要对服务器响应时间进行实时监控和调整权重，实现较为复杂。
5. 最短预测时间算法：可以根据历史数据预测未来响应时间，但需要对历史数据进行分析和建模，实现较为复杂。

综上所述，不同的负载均衡算法适用于不同的场景，需要根据具体的需求进行选择。同时，客户端负载均衡算法的实现也需要考虑可靠性、性能、可扩展性等因素。





RIP（Routing Information Protocol）和OSPF（Open Shortest Path First）是两种常用的路由协议。下面是它们之间的对比：

1. 路由类型：
   - RIP是一种距离向量协议，以跳数为衡量标准。
   - OSPF是一种链路状态协议，它考虑链路的带宽和成本。
2. 路由更新：
   - RIP的路由更新是定期发送到相邻路由器，并且整个路由表会被重新发送。这会导致大量的网络流量。
   - OSPF的路由更新是基于链路状态发生变化时才会发生，它只会发送与变化相关的部分路由更新，而不是整个路由表。
3. 支持的网络规模：
   - RIP适用于小型网络，最多支持15跳。
   - OSPF适用于大型网络，可以支持多达数千个路由器。
4. 路由计算：
   - RIP使用贝尔曼-福德算法进行路由计算，这种方法具有很高的计算成本。
   - OSPF使用Dijkstra算法进行路由计算，这种方法比贝尔曼-福德算法更有效率。
5. 路由选择：
   - RIP使用距离向量算法进行路由选择，只考虑跳数，不能优化路由选择。
   - OSPF使用最短路径优先算法进行路由选择，考虑带宽和成本，可以优化路由选择。
6. 安全性：
   - RIP没有加密路由信息的功能，容易受到攻击。
   - OSPF支持身份验证和加密路由信息的功能，具有更高的安全性。

总的来说，RIP适用于小型网络，而OSPF适用于大型网络。OSPF比RIP更具有优化路由选择和安全性的优点，但计算成本也更高。



14

- 函数返回值类型推导 auto func(*)

- #### constexpr的限制 在C++14中可以使用局部变量和循环 C++11中constexpr函数必须必须把所有东西都放在一个单独的return语句中

- #### shared_lock



#### 17 特性

- 结构化绑定

- std::optional

- std::string_view

- #### 构造函数模板推导 pair



11

- 智能指针

- 类型转换

- 右值引用

- lameda表达式

- thread类

- auto decltype overridd

  





软中断是一种在 Linux 操作系统中使用的特殊中断机制，用于执行内核中的代码。以下是常见的软中断：

1. system_call：用于执行系统调用。
2. page_fault：用于处理页面错误。
3. timer_interrupt：用于处理定时器中断。
4. tasklet_hi/tasklet：用于处理异步事件，例如网络数据包的到达。
5. workqueue：用于在内核中异步执行工作，例如处理磁盘 I/O。
6. syscall_exit：用于在系统调用结束时执行清理工作。
7. signal_trap：用于处理信号。
8. irq_poll：用于轮询外部设备的状态。
9. rcu_bh/rcu_sched：用于执行读取-复制更新（RCU）机制，用于在多处理器系统中进行无锁访问。





g++优化级别：

1. -O0（无优化）：这是默认的优化等级，它不进行任何优化。
2. -O1（基本优化）：这个等级进行基本的优化，例如删除未使用的代码、简化代码和常量表达式、强制内联等等。
3. -O2（标准优化）：这个等级进行更多的优化，包括调整代码布局以提高缓存局部性、对循环进行向量化优化、减少函数调用等等。
4. -O3（更高的优化）：这个等级进行更加激进的优化，例如使用更快的数学库函数、进一步调整代码布局、使用更高效的寄存器分配算法等等。
5. -Ofast（快速优化）：这个等级进行更加激进的优化，包括使用更快的数学库函数和向量化指令、取消指令和数据的依赖关系等等，但可能会导致代码的行为与标准规范不同。
6. -Os（优化代码大小）：这个等级的目标是最小化生成的机器代码的大小，从而减少程序占用的空间。它使用一些优化技术，如删除未使用的函数和变量、使用较短的指令序列等等。



#### http缓存策略

强制缓存 在过期前 只要发现缓存中有 就直接用缓存 cache-control字段 用于判断缓存策略 以及 过期时间 等

对比缓存 发送请求给http服务器 返回如果是304 则代表资源未被修改 可以直接用缓存 不然则需要重新访问





#### redis命令

set get

lpush rpush lpop rpop

hset hget

sadd srem 

setnx expire 
