#### linux内核是什么 如何进行内核交互

----

Linux 内核包含五大子模块

1、内管管理

内存管理主要完成是如何合理有效地管理整个系统的物理内存，同时快速响应内核各个子系统对内存分配的请求。Linux内存管理支持虚拟内存，而多余出的这部分内存就是通过磁盘申请得到的，平时系统只把当前运行的程序块保留在内存中，其他程序块则保留在磁盘中。在内存紧缺时，内存管理负责在磁盘和内存间交换程序块。

2、进程管理
进程管理主要控制系统进程对CPU的访问。当需要某个进程运行时，由进程调度器根据基于优先级的调度算法启动新的进程。Linux支持多任务运行，那么如何在一个单CPU上支持多任务呢？这个工作就是由进程调度管理来实现的。在系统运行时，每个进程都会分得一定的时间片。然后进程调度器根据时间片的不同，选择每个进程一次运行。例如当某个进程的时间片用完后，调度器会选择一个新的进程继续运行。由于切换的时间和频率都非常快，由此用户感觉是多个程序在同时运行，实际上CPU在同一时间内只有一个进程在运行。

3、进程间通信
进程间通信主要用于控制不同进程之间在用户空间的同步、数据共享和交换。由于不同的用户进程拥有不同的进程空间，因此进程间的通信要借助于内核的中转来实现。一般情况下，当一个进程等待硬件操作完成时，会被挂起。当硬件操作完成，进程被恢复执行，而协调这个过程的就是进程间的通信机制

4、虚拟文件系统
Linux内核中的虚拟文件系统用一个通用的文件模型表示了各种不同的文件系统，这个文件模型屏蔽了很多具体文件系统的差异，使Linux内核支持很多不同的文件系统，这个文件系统可以分为逻辑文件系统和设备驱动程序：逻辑文件系统指Linux所支持的文件系统，例如ext2、ext3和fat等；设备驱动程序指为每一种硬件控制器所编写的设备驱动程序模块

5、网络接口 
网络接口提供了对各种网络标准的实现和各种网络硬件的支持。网络接口一般分为网络协议和网络驱动程序。网络协议部分负责实现每一种可能的网络传输协议。网络设备驱动程序则主要负责与硬件设备进行通信，每一种可能的网络硬件设备都有相应的设备驱动程序

- 可以用linux提供的capi进行交互 如read open malloc这类 **直接** 与系统交互的函数

- procfs procfilesystem 是内核提供的 对系统进行配置的方式 如proc文件夹下 就保存了大量的系统信息 如外设信息 内存信息 cpu信息 tty信息 还有各类进程 网络的信息

 例如进制转发IP数据包，可以设置如下：

echo 1 > /proc/sys/net/ipv4/ip_forward

- sysctl接口 可以用于调用
- brk函数可以用来改变给堆分配的地址
- fstat可以获取文件属性
- ioctl 对设备通讯I/O进行管理

##### 用户态和内核态

![image-20220724191911361](/Users/whz/Library/Application Support/typora-user-images/image-20220724191911361.png)

一般的应用程序是在linux内核的基础上 通过库函数 或者 shell脚本 这些方法 去系统调用内核来实现的

内核态是一种**特殊的软件程序**，内核会帮助我们**控制计算机的硬件资源，例如协调CPU资源，分配内存资源** 以及别的功能 参见上述五条内容

用户态是我们正常的程序的运行空间 我们在用户态运行的程序中 会使用系统调用 通过内核提供的接口 去操作内核的资源 

---

#### 如何检查内存泄漏问题

如果是已经运行的程序 用top命令可以检查

如果是在代码中 用静态分析工具 mtrace

修改源程序： 添加头文件，并且用mtrace()和muntrace()两条语句将要检测内存泄露的代码块包含起来

然后运行时就会产生错误

也可以自己写一个 在每次new时都将位置记录在一个数组中 delete时删除 这样就可以得很清楚的知道哪些被释放了 哪些益处了

---

#### TCP 三次握手 四次挥手 连接队列

![img](https://pic3.zhimg.com/80/v2-e8aaab48ff996e5cd8a5b39dc450bd6a_1440w.jpg)



3次握手”的作用就是`双方都能明确自己和对方的收、发能力是正常的`。

首先 客户端给服务端发送SYN同步信号 服务端接收到信号 这时候 服务端知道客户能发信号 但是不知道他能不能接受信号

于是 服务端发包 用一个SYN+ACK包 回应了服务端的请求 这时候 客户端就知道 服务端是可以接受我的信号 并发送

然后这是 客户端回一个信号ACK告诉服务端 我也能接收到你的信号 

至此 双方都明白了对方能接受自己的信号并且回信 通信开始



四次挥手 首先客户端给服务端发送Fin信号 告诉服务端 我想要结束 

服务端收到消息 发送ACK给客户端 告诉他收到了服务端想要结束的请求 于是开始结束前的准备

当服务端这边也可以结束的时候 也会发送一个FIN给客户端 告诉说我可以结束

客户端收到后 返回ACK确认信息 服务端收到后 链接断开

上述过程 四次挥手能保证双方都能在自己的事情完成后再断开链接 同时也能通知到对方



连接队列和半连接队列：

![image-20220711211026443](/Users/whz/Library/Application Support/typora-user-images/image-20220711211026443.png)

一个链接在服务器响应 但是客户端没有响应的时候 会被放入一个半连接队列 知道客户端正式作出响应 然后被拿到全链接队列

连接队列里记录了所有连接的信息

注意 一个socket可以对应一个链接  当有新的连接进来的时候, 都可以通过 accept 系统调用让操作系统接受一个新的连接, 同时返回一个新的socket, 然后你可以拿着这个新产生的socket 进行写入和读取等操作(因为它是一个文件描述符). 那个用来listen的socket 和这个新的socket 是不相关的,在操作系统内部也是分开的,会有各自的缓冲区等.

原始的IO多路复用就是多进程模型，为每一个socket连接分配一个进程来处理。主进程负责监听accept()，每次有新的连接就开辟一个子进程来处理。由此可见，主进程和子进程承担了不同的角色。

![image-20220711211500357](/Users/whz/Library/Application Support/typora-user-images/image-20220711211500357.png)

![image-20220711211852778](/Users/whz/Library/Application Support/typora-user-images/image-20220711211852778.png)

上面是两种原生的处理模型

accept每次只能返回一个连接，这个连接相应的网络io（socket）是否可读可写我们并不知道，read时很可能会阻塞住。而select可以解决这个问题，我们把关注的io和对应事件，通过select注册，当事件发生时，select会通知我们。

可以用selec来实现更高的性能

select 实现多路复用的方式是，将已连接的 Socket 都放到一个集合**文件描述符集(fd_set)**，然后调用 select 函数将文件描述符集合**拷贝(第一次拷贝)**到内核里，让内核来检查是否有网络事件产生，内核检查的方式很简单粗暴，就是通过**遍历文件(第一次遍历)**描述符集合的方式，当检查到有事件产生后，将此 Socket 标记为可读或可写，接着再把整个文件描述符集合**拷贝(第二次拷贝)**回用户态里，然后用户态还需要再通过**遍历(第二次遍历)**的方法找到可读或可写的Socket，然后再对其处理。

##### UDP如何实现可靠连接



---

#### http和https

http是一种请求/响应协议 通常运行在tcp之上 

HTTP 之所以被 HTTPS 取代，最大的原因就是不安全 因为在http传输过程中 内容都是未经过加密的明文 一旦被截取 就会导致信息泄漏的风险 所以我们需要对http加密 通过一串秘匙来加密内容 这样就算被截取了 也无法被破译

**对称加密** ： 双方使用同一把钥匙 好处是计算量小 坏处是钥匙钥匙也被截取了 就不能保证安全了

**非对车加密** ：加密方和破译方使用两把不同的钥匙 服务端在一开始会生成两把钥匙 把其中一把作为公匙 每当有链接建立 就把公匙发送给客户端 客户端根据这个公匙去生成加密文件 然后把文件用http发送给客户端 在服务端破译时 需要私匙才能解开 这样就保证了就算被第三方截取 也无法破解

SSL TSL 表示层架秘

**证书**: 非对称加密解决了安全性 但是还有一点 我们如果确保客户端收到的公钥是客户端发来的呢，如果是伪造的公匙 那么很可能也会被破译 这就需要用到证书 网站在使用HTTPS前，需要向**CA机构**申领一份**数字证书** 包含服务器的具体信息 相当于身份证明 来证明身份的有效性 

**如何防止证书被篡改**？ 我们根据证书去生成一份数字签名 签名过程如下: 

1. CA机构拥有非对称加密的私钥和公钥。
2. CA机构对证书明文数据T进行hash。
3. 对hash后的值用私钥加密，得到数字签名S。

明文和数字签名共同组成了数字证书

浏览器验证的方法是用公钥对数字签名进行解密 ，

1. 拿到证书，得到明文T，签名S。
2. 用CA机构的公钥对S解密（由于是浏览器信任的机构，所以浏览器保有它的公钥。详情见下文），得到S’。
3. 用证书里指明的hash算法对明文T进行hash得到T’。
4. 显然通过以上步骤，T’应当等于S‘，除非明文或签名被篡改。所以此时比较S’是否等于T’，等于则表明证书可信。

---

#### http 1 1.1 2.0 3.0

Http1 默认为短链接 就是每次请求都会新建一个tcp链接

在Http1.1中 更改为默认为长连接 默认传入keep-alive参数 可以减小TCP不断的挥手 握手带来的开销，同时 http允许以一种管道的方式来提高传输效率 当一个请求没有得到回应时，仍然可以发送下一个请求 以提升效率 

但是虽然客户端可以发送多个请求 但是服务器还是会按照接受顺序来返回 也就是说 我们有请求1 2 就算2已经准备好了 1还没有准备好 2也是不能返回的 一定要等待1返回先

Http2.0较于1.1 做出了更多的性能优化 包括：

1. 压缩请求头 减少重复数据
2. 二进制分帧 通过在应用层和传输层之间增加一个二进制分层帧 增加效率
3. 服务器除了最初请求的响应外，服务器还可以额外向客户端推送资源
4. 请求和应答以流的形式发送 一个流可以拆分成多个帧 每个帧都有自己的流id Stream_id 这样就可以不考虑相应的顺序 做到真正的并发

但是 仍然存在问题 例如 因为使用的是tcp链接 所以当发生丢包时，就需要等待 然后重传 发生阻塞 为了解决这个问题 就有了http3 基于quic(udp)的协议

---

#### 内联函数

函数调用是有时间和空间开销的。程序在执行一个函数之前需要做一些准备工作，要将实参、局部变量、返回地址以及若干寄存器都压入栈中，然后才能执行函数体中的代码；函数体中的代码执行完毕后还要清理现场，将之前压入栈中的数据都出栈，才能接着执行函数调用位置以后的代码。

在函数比较短小的时候 我们就可以写成内联的形式来减少切换所带来的开销。

具体做法是 用inline关键字 在函数定义(注意不是声明)的时候加入这个关键字 就可以让这个函数变成内联

 inline 关键字告诉编译器用函数定义中的代码替换每个函数调用实例。

同时直接在类内定义的函数也都是内连的

---

#### 未初始化和初始化的静态变量分别放在哪里？

已初始化的全局变量和局部静态变量都在`__data`段中，而未初始化的全局变量在`__common`段中，未初始化的局部静态变量在`__bss`段中。

----

#### vector中resize和reverse

reverse和resize都是用来调整vector容量的

不同之处在于 resize是调用了构造函数对每个元素进行了初始化，也就是说可以直接用下表去获取到这个元素

但是reverse只是类似于预留了空间的大小 直接用下标获取会报错 只能用push_back

同时 如果resize和reverse的大小比原先vector大小要更好 结果也是不一样的.

resize会直接将超出部分舍弃 而reverse则是不会改动已有的区域

---

#### Map insert和用下标的区别

首先 如果该key存在 用下标形式的话会强制更新该key-value 如果用的是insert的话 则会被忽略

其次 如果该key不存在的话 两个都会创建

值得注意的是 向map容器中增添元素，insert()效率更高 , 而更新map容器中的键值对，operator[]效率更高

---

#### const char *

**const char \***与**char const \*** 效果一样，可以看先把const 和 char结合起来，都是不允许修改指针指向的地址空间的值，即把值作为常量，而**char \* const**则是不允许修改指针自身，不能再指向其他地方，把指针自己当作常量使用。需要注意的是，使用**char \* const** 定一个常量指针的时候一定记得赋初始值，否则再其他地方就没法赋值了。

---

#### vector为什么以1.5或者2倍扩容

在VS 下是*1.5倍*，在GCC 下是*2 倍*

空间和时间的权衡。

简单来说， 空间分配的多，平摊时间复杂度低，但浪费空间也多。

因为如果每次只加一点 就会导致很快就需要再次添加 时间上很不划算

但是加的太多了 又用不上 造成浪费

---

#### 哈希表 哈希函数 哈希碰撞

##### 如何构建哈希函数

1. 直接定址法 f(key)=a*key+b 

   很少用

2. 平方取中法

   将关键字先平方，然后截取中间x位作为存储位置

3. 除留余数法 f(key)=key mod p (p<=m)

   p取小于等于m的最小质数或者不包含小于20质因子的合数，以减少冲突的情况

##### 解决办法

开放定址法
使用某种探测算法在散列表中寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到。就是即使key产生hash冲突，也不会形成链表，而是将所有元素都存入哈希表里。发生hash冲突时，就以当前地址为基准，进行再寻址的方法去寻址下一个地址，直到找到一个为空的地址为止。

再哈希法
这种方式是同时构造多个哈希函数，当产生冲突时，计算另一个哈希函数的值。

这种方法不易产生聚集，但增加了计算时间。

链地址法

使用链表来保存发生hash冲突的key

建立公共溢出区
将哈希表分为基本表和溢出表两部分，为所有发生hash冲突的关键字记录一个公共的溢出区来存放。在查找的时候，先与哈希表的相应位置比较，如果查找成功，则返回。否则去公共溢出区按顺序一一查找。在冲突数据少时性能好，冲突数据多的时候耗时

---

#### 共享内存是什么 怎么实现

共享内存（Shared Memory），指两个或多个进程共享一个给定的存储区。进程可以将同一段共享内存连接到它们自己的地址空间中，所有进程都可以访问共享内存中的地址，就好像它们是由用C语言函数malloc分配的内存一样。而如果某个进程向共享内存写入数据，所做的改动将立即影响到可以访问同一段共享内存的任何其他进程。

```cpp
#include <sys/ipc.h>
#include <sys/shm.h>
int shmget(key_t key, size_t size, int shmflg);
void *shmat(int shmid, const void *shmaddr, int shmflg);
创建和挂载
```

---

#### 说一下Malloc工作原理 new的工作原理

它首先会扫描之前由free()所释放的空闲内存块列表，以求找到尺寸大于或等于要求的一块空闲内存，如果这一内存块的尺寸正好与要求想当，就把该内存块地址直接返回给调用者，如果是一块较大的内存，那么将对其进行分割，在将一块大小相当的内存返回给调用者的同时，把较小的那块空闲内存保留在空闲列表中。如果空闲内存列表中没有足够大的空闲内存块，那么malloc()会调用sbrk()以分配更多的内存。为减少对sbrk()的调用次数，malloc()并未只是严格按所需字节数来分配内存，而是以更大幅度(以虚拟内存页大小的数倍)来增加program break，并将超出部分置于空闲内存列表

malloc()分配内存块的时候，会额外分配几个字节来记录内存块的大小，该数值存放在内存块的起始处，malloc()实际返回给调用者的地址其实是该数值之后的内存块长度。

---

#### cgroups

----

#### nginx负载均衡内容

---

#### 哈夫曼树和哈夫曼压缩算法

---

#### 一致性哈希

----

#### DNS

区域传送时使用TCP，主要有一下两点考虑： 
1.辅域名服务器会定时（一般时3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，则会执行一次区域传送，进行数据同步。区域传送将使用TCP而不是UDP，因为数据同步传送的数据量比一个请求和应答的数据量要多得多。 
2.TCP是一种可靠的连接，保证了数据的准确性。 

域名解析时使用UDP协议： 
客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过TCP三次握手，这样DNS服务器负载更低，响应更快。虽然从理论上说，客户端也可以指定向DNS服务器查询的时候使用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包。

---

#### 说一说new和malloc的区别以及底层的工作原理

malloc和free是c/c++的库函数，new和delete并不是标准库函数，可以看作是c++的一个运算符。

new可以看作是对malloc的上层封装，注意，如果用malloc开辟对象，**是不会调用构造函数和析构函数的**。

同时，使用`new`操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。

`C++`允许重载`new/delete`操作符

##### malloc的基本原理

malloc会维护一个很长的空闲内存的链表，每当我们申请内存时，malloc就回去寻找一个大小合适的内存区域，交还给我们，同时，在我们释放的时候，将该区域加入空闲链表

不难看出 这样的话内存区域到最后会越划越小，一旦某次找不到合适的空闲区域的时候，malloc会对连续的空闲区域进行一个合并。

如果内存大小不够，会用brk和sbrk函数来重新划定堆区边界

brk通过传递的addr来重新设置program break，成功则返回0，否则返回-1。而sbrk用来增加heap，增加的大小通过参数increment决定，返回增加大小前的heap的program break，如果increment为0则返回program break。

---

进行函数调用，栈怎么动态分配，和CPU寄存器怎么联动，数据怎么同步到内存 

 为什么一个操作系统可以运行多个进程，核心技术是什么 

 进程的地址空间是什么样的 

 C++对main函数进行编译后形成二进制文件，格式是什么，怎么让操作系统把文件变成进程 

 动态链接相对静态链接解决的问题是什么 

 ping的工作原理，发送的是什么包 

 IP包大小有限制吗 

 HTTP/1.1的局限性

如何基于UDP实现可靠传输？

---

#### tcp和udp 选择

选择udp的情况:

1. 考虑实时性 比如直播 或者网络游戏 当发生丢包的时候 我们不需要进行一直重传 因为之前的数据已经是没有意义的了 tcp是稳定连接 所以会一直间隔一段时间去重新发请求，而对于udp 报文的重发选择权在我们自己手里
2. 考虑资源消耗 tcp在使用的时候需要一直维持连接 而对于一些短暂性的 数据量也比较小的数据交换场景 udp就更加合适

----

#### Tcp udp 包大小限制

IP层没有超时重传机制, 如果IP层对一个数据包进行分片, 只要有一个分片丢失, 就需要依赖传输层进行重传, 结果是所有的分片都要重传一遍, 因此我们要尽量避免IP分片.

避免ip分片 最好的方法就是让所有数据包小于MTU

*TCP*的*最大报文*段*长度*即MSS一般是1460字节（1500(MTU) - 20(IP head) - 20(*TCP* head) = 1460 Byte

UDP 包的大小就应该是 1500 - IP头(20) - UDP头(8) = 1472(Bytes)

---

#### UDP实现可靠连接

因为udp本身是不可靠的 所以我们需要利用上层协议来帮助实现更可靠的连接

1. 重排机制 因为不同的udp包可能在发送的接收端的时间并不一样，这会导致顺序混乱，所以我们需要在上层协议中定义重排机制
2. 重传机制 需要接受方给出应答 在一定时间后判断是否需要重传
3. 流量控制 比如拥塞控制 

quic kcp 都是基于udp的可靠传输协议

---

#### 在4g的机器上 申请8g的内存

前面讨论在 32 位/64 位操作系统环境下，申请的虚拟内存超过物理内存后会怎么样？

- 在 32 位操作系统，因为进程最大只能申请 3 GB 大小的虚拟内存，所以直接申请 8G 内存，会申请失败。
- 在 64 位操作系统，因为进程最大只能申请 128 TB 大小的虚拟内存，即使物理内存只有 4GB，申请 8G 内存也是没问题，因为申请的内存是虚拟内存。

程序申请的虚拟内存，如果没有被使用，它是不会占用物理空间的。当访问这块虚拟内存后，操作系统才会进行物理内存分配。

如果申请物理内存大小超过了空闲物理内存大小，就要看操作系统有没有开启 Swap 机制：

- 如果没有开启 Swap 机制，程序就会直接 OOM；
- 如果有开启 Swap 机制，程序可以正常运行。

当系统的物理内存不够用的时候，就需要将物理内存中的一部分空间释放出来，以供当前运行的程序使用。那些被释放的空间可能来自一些很长时间没有什么操作的程序，这些被释放的空间会被临时保存到磁盘，等到那些程序要运行时，再从磁盘中恢复保存的数据到内存中。

另外，当内存使用存在压力的时候，会开始触发内存回收行为，会把这些不常访问的内存先写到磁盘中，然后释放这些内存，给其他更需要的进程使用。再次访问这些内存时，重新从磁盘读入内存就可以了。

这种，将内存数据换出磁盘，又从磁盘中恢复数据到内存的过程，就是 Swap 机制负责的。

----

#### linux查看核数，查看内存

```
cat /proc/cpuinfo
cat /proc/meminfo
```

---

#### 查看端口

```
lsof -i:80
netstat -tunlp | grep 80
　　-t : 指明显示TCP端口

   -a : 显示所有socket(套接字)，包括正在监听的（LISTEN）

　　-u : 指明显示UDP端口

　　-l : 仅显示监听套接字(所谓套接字就是使应用程序能够读写与收发通讯协议(protocol)与资料的程序)

　　-p : 显示进程标识符和程序名称，每一个套接字/端口都属于一个程序。

　　-n : 不进行DNS轮询，显示IP(可以加速操作)
```

---

#### SYN Flood 的原理？有哪些防范的方法

客户端发送三次握手的第一个 SYN 报文后收到服务器的报文却不回应，从而导致服务器的半开资源浪费直到超时释放

- 方法一：限制 SYN 并发数
- 方法二：网站上 `CDN`，隐藏源站 IP，让 `CDN` 抵抗攻击
- 方法三:   禁止特定范围的ip : iptables -A INPUT -s 192.168.5.1/8 -i eth0 -j Drop

SYN Cookie是对TCP[服务器](https://baike.baidu.com/item/服务器/100571)端的[三次握手协议](https://baike.baidu.com/item/三次握手协议/6042714)作一些修改，专门用来防范SYN Flood攻击的一种手段。它的原理是，在TCP服务器收到TCP SYN包并返回TCP SYN+ACK包时，不分配一个专门的数据区，而是根据这个SYN包计算出一个cookie值。在收到TCP ACK包时，TCP服务器再根据那个cookie值检查这个TCP ACK包的合法性。如果合法，再分配专门的数据区进行处理未来的TCP连接。

---

#### 水平出发和边缘触发

水平触发（LT）：只要缓冲区有数据，epoll_wait就会一直被触发，直到缓冲区为空；（有数据会连续触发）

边沿触发（ET）:只有所监听的事件状态改变或者有事件发生时，epoll_wait才会被触发；（有数据只触发一次）

边沿出发效率更高 但有可能造成漏掉数据

